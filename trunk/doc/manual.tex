\documentclass[11pt]{book}
\usepackage{makeidx}
\usepackage{appendix}
\usepackage{ifthen}
\usepackage{listings}
\usepackage{verbatim}
\usepackage[pdfpagemode=UseOutlines,bookmarks,bookmarksopen,
pdfstartview=FitH,colorlinks,linkcolor=blue,
pdftitle={POET Language Manual},
pdfauthor={Qing Yi},
citecolor=blue,urlcolor=red]{hyperref}
\textwidth 6.5in
\textheight  8.8in
\oddsidemargin  0in
\evensidemargin 0in
\topmargin      -0.3in
\parindent      0.25in

\let\cleardoublepage\clearpage
%\def\bs{\char'134 } % backslash in \tt font.
%\newcommand{\ie}{i.\,e.,}
%\newcommand{\eg}{e.\,g..}
%\DeclareRobustCommand\cs[1]{\texttt{\char`\\#1}}
\makeindex 

\title{POET Reference Manual}
\author{ Qing Yi \\
  University of Texas At San Antonio \\(qyi@uccs.edu) }

\begin{document}

\maketitle

{\bf \Large \center Front Matter}

POET is an interpreted program transformation language designed to apply  
source-to-source transformations to programs written in arbitrary
languages such as C, C++, Java or any domain-specific ad-hoc languages.
The POET language has been extensively used for the purpose of  
applying parameterized compiler optimizations to improve the performance
(i.e., the runtime efficiency) of C programs, so that differently optimized code
can be automatically generated and empirically tuned.
The use of POET, 
however, is not limited to compiler optimizations. 
You can use POET
to easily process any structured input code, extract information from 
or apply transformations to the input,  and then output the result. 

The POET language was designed and implemented by the research group lead by Dr. Qing Yi
at the University of Texas at San Antonio during 2007-2012. The project has been moved to 
the University of  Colorado, Colorado Springs since 2012. 
Please directed all questions and feedbacks to her at qyi@uccs.edu. 

\vspace{.2in}
Qing Yi 

9/1/2011

%The current release of POET includes five directories: src, lib, doc, test, and examples.
%The $src$ directory contains C/C++/Yacc/Lex code for the POET language interpreter;
%the $lib$ directory contains the existing POET libraries that include an extensive collection
%of language descriptions and program xform routines useful both for software
%optimization and evolution;
%the $doc$ directory contains documentations about the POET language;
%the $test$  directory contains some example applications of
%the POET code; and the $examples$ directory contains some stand-alone POET
%code that serve as examples in POET tutorials. 


\begin {center}
 {Copyright (c)  2008,  Qing Yi.  All rights reserved.}\\
Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
\begin {enumerate}
\item Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
\item Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
\item Neither the name of UTSA nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
\end {enumerate}
\end {center}

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

\addcontentsline{toc}{section}{Table Of Content}
\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Building and Using POET}
%%%%%%%%%%%%%%%%%%%%%%%%

\section{Building POET From Distribution}
After downloading a POET distribution, say poet-1.02.06.tar.gz, you can build POET
using the following commands.
\begin {verbatim} 
> tar -zxf poet-1.02.07.01.tar.gz 
> cd poet-1.02.07.01
> ./configure --prefix=<your install directory>
>  make     (make and then run the POET interpreter on a few tests)
> make check (test whether the POET interpreter works correctly)
> make install (install POET interpreter and libraries on your local machine)
\end {verbatim}

\section{Building POET From SVN repository}
If you have access to the POET internal git repository, you can build POET using the following commands.
\begin {verbatim}
> git clone git.machine://git.directory/POET/trunk
> cd POET
> aclocal
> automake -a
> autoconf
> ./configure
>  make     (make and then run the POET interpreter on a few tests)
> make check (test whether the POET interpreter works correctly)
\end {verbatim}

\section {Directory Structure of POET Source Distribution}
The POET interpreter is implemented in C++.
The distribution of POET includes the following sub-directories.
\begin {itemize}
\item The $src$ directory, which contains the C/C++/YACC/LEX code used to implement POET.
\item The $lib$ directory, which contains libraries implemented using POET.
\item The $test$ directory, which contains POET scripts used to test POET releases.
\item The $examples$ directory, which contains examples used in various POET tutorials.
\item The $doc$ directory which contains the manual and tutorials for POET.
\end {itemize}

\section{Using POET}
\label {sec-usePOET}
Each POET release includes the language interpreter, named $pcg$,
and various POET library files. 
After running {\it make install}, the binary interpreter $pcg$ is copied to directory $<$your install directory$>$/$bin$,
and the POET libraries are copied to $<$your install directory$>$/$lib$. 
The command line options for running $pcg$ are as follows.
\begin {verbatim}
Usage: pcg [-bhv] {-L<dir>} {-p<name>=<val>} <poet_file1> ... <poet_filen>
options:
     -h:      print out help info
     -v:      print out version info
     -c<i>:   verify the first i conditions only (exit without evaluating the program)
     -L<dir>: search for POET libraries in the specified directory
     -p<name>=<val>: set POET parameter <name> to have value <val>
     -dp:     print out debugging info for parsing operations
     -dl:     print out debugging info for lexical analysis
     -dx:     print out debugging info for xform routines
     -dm:     print out debugging info for pattern matching
     -md:     allow global names to be multiply-defined (overwritte)
     -dt:     print out timing information for various components of the POET interpreter
     -dy:   print out debugging info from yacc parsing
\end {verbatim}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter {Building Translators: Getting Started}
\label {chap-examples}
This chapter goes over some  example POET translators in the POET/examples directory.
\newcounter {note}
\newcommand {\note} {\addtocounter{note}{1} \vspace{2mm} \noindent {\bf NOTE\thenote}: }
\section {Hello World}
The following simple POET program (POET/exampls/helloworld.pt) prints out the string ``hello world" to standard output.
\begin {verbatim}
<************* Hello World Script *********>
<output from="hello world"/>
\end {verbatim}

\note All POET comments are either enclosed inside a pair of $<$* and *$>$, or from $<$$<$* until the end of
the current line. 
Specifically, all strings enclosed within $<*$ and $*>$ will be ignored by the POET interpreter,
and all strings following $<<*$ until the end of line will be ignored.

\section{The Identity Translator}
\label {sec-identity-translator}

First and foremost, POET is designed to build translators. The easiest kind of translator
is an identity translator, which reads the input code from an arbitrary file, does nothing, and then writes the input code to a different file. The following POET code (POET/examples/IdentityTranslator.pt) does exactly this.
\begin {verbatim}
<********** The Identity Translator ****************>
<parameter inputFile default="" message="input file name" />
<parameter outputFile default="" message="output file name" />

<input from=inputFile annot=0 to=inputCode/>
<output to=outputFile from=inputCode/>
<********** The Identity Translator ****************>
\end {verbatim}

\note 
Each {\it parameter} declaration  declares a global 
variable whose value can be modified via command-line options. 
For example, the identity translator can be invoked using the following command. \\
{\it $>$ pcg -pinputFile=myFile1 -poutputFile=myFile2 IdentityTranslator.pt }\\
The command-line options are optional as long as a default value (declared using the $default$ keyward) is given for each parameter. 

\note
Each {\it input} command opens a list of  input files and saves the content of the files as the content of 
a global variable (here the $inputCode$ variable). The  $annot=0$ specification ensures that 
the input files will be read as a sequence of integer/string tokens and all annotations in the file will be ignored.
%otherwise, the input code is parsed based on the grammar definition contained in file $inputLang$ (enforced by the $syntax=inputLang$ specification), and if the input code contains POET annotations,
%the annotations will be used to help the parsing process.\note The {\em syntax} attribute in the $input$ and $output$ commands specifies what language syntax 
to use when parsing/unparsing the input/output code. 


\note
%Each $output$ command similarly has a $cond$ specification which enforces that the first $output$
%command is evaluated only when
%$inputLang$ is empty (no language syntax is defined for the input code), and the second $output$
%command is evaluated only when $inputLang$ is not empty (a language syntax file is specified).
Each $output$ command opens an external file and then outputs the content of  an expression 
 into the external file. 
%If $inputLang == ""$, the input code will be output as a sequence of integer/string
%tokens;
%otherwise, the input code is unparsed based on the grammar definition contained in file $inputLang$ (enforced by the $syntax=inputLang$ specification).

\note When the input file name is an empty string, the $input$ command will read from
the standard input (the user will be prompted to type in the input); when the output file name is
an empty string, the $output$ command will write to the standard output (the screen).

%as illustrated by the $inputCode$ variable, variables in POET can be used without being declared.  
%%%%%%%%%%%%%%%%%%
\section{The String Translator}
\label {sec-string-translator}

In general, after reading some input files, we would like to apply some transformation and then
output the transformed code. The following POET program (POET/examples/StringTranslator.pt) 
serves to substitute a pre-defined set of strings with other strings.
\begin {verbatim}
<********** The String Translator ****************>
<parameter inputFile default="" message="input file name" />
<parameter outputFile default="" message="output file name" />
<parameter inputString type=(STRING...) default="" message="string to replace" />
<parameter outputString type=(STRING...) default="" message="string to replace with" />

<input from=inputFile annot=0 to=inputCode/>

<eval 
res = inputCode;
for ((p_input = inputString,p_output=outputString); p_input != NULL;
      (p_input = TAIL(p_input); p_output=TAIL(p_output)))
   { res = REPLACE(HEAD(p_input), HEAD(p_output), res);}
/>

<output to=outputFile from=res/>
\end {verbatim}
\note  The $type$ attribute within a parameter declaration ensures that only a value of proper type
can be assigned to the parameter. In particular,  the type $(STRING...)$ specifies a list of strings.

\note The $eval$ command is used to evaluate expressions and statements at the global scope.
All POET expressions must be embedded within an eval command to be evaluated at the
global scope.

\note POET supports assignment statements and for loops in a similar fashion as the C language.
Because POET is dynamically typed, variables in POET do not need to be declared.

\note The HEAD and TAIL keywords are operators that extract values from a list (see section~\ref {sec-op-list}). Specifically, $HEAD$ returns the first element in the list,
$TAIL$ returns the tail of elements in the list (excluding the first one). 
If the operand $list$ is actually a single value, then 
$HEAD(list)$ returns the single value, and $TAIL(list)$ returns $NULL$.

\note The REPLACE keyword is a built-in operator for systematically applying transformations (replacements) to an input expression.

\paragraph{Transformation Logic:} The example loop first initializes two variables, $p\_input$ and $p\_output$,
with the values of global variables $inputString$ and $outputString$ respectively (each variable
has a list of strings as content). 
It then examines whether $p\_input$ is an empty string. As long as $p\_input$ is not empty,
the body of the $for$ loop is evaluated, which modifies the value of the $res$ variable by 
invoking the built-in $REPLACE$ operator.
Each time the $REPLACE$ operator is invoked, it replaces all the occurrences of $HEAD(p\_input)$
with $HEAD(p\_output)$ in the input code contained in the $res$ variable, where $HEAD(\_input)$
and $HEAD(p\_output)$ returns the first string contained $p\_input$ and $p\_output$ respectively.
At the end of each iteration, both $p\_input$ and $p\_output$ are modified with the $TAIL$
of their original values. 

%%%%%%%%%%%%%%%%%%
\section{Language Translators}
\label {sec-lang-driver}
%%%%%%%%%%%%%%%%%

Instead of reading an input file as a sequence of strings, we frequently need to discover the syntactical 
structure of the input file. This is called parsing. For example, the following translators (POET/examples/C2C.pt and C2F.pt) reads and parses the syntax of  a C program, and then unparses the code to an external file
in either C syntax or Fortran syntax.

\begin {verbatim}
<*************** C to C Translator *************>
<parameter inputFile type=STRING default="" message="input file name" />
<parameter outputFile type=STRING default="" message="output file name" />

<input from=inputFile syntax="Cfront.code" to=inputCode/>
<* You can add transformations to the inputCode here *>
<output to=outputFile syntax="Cfront.code" from=inputCode/>
\end {verbatim}

\begin {verbatim}
<*************** C to Fortran Translator *************>
<parameter inputFile type=STRING default="" message="input file name" />
<parameter outputFile type=STRING default="" message="output file name" />

<input from=inputFile syntax="Cfront.code" to=inputCode/>
<output to=outputFile syntax="C2F.code" from=inputCode/>
\end {verbatim}

\note The {\em syntax} attribute in the $input$ and $output$ commands specifies what language syntax 
to use when parsing/unparsing the input/output code. 


\note 
The syntax files {\em Cfront.code} and {\em C2F.code} are stored  in the POET/lib directory.
The {\em Cfront.code} file contains syntax definitions for parsing/unparsing C programs. 
The {\em C2F.code} file contains corresponding Fortran syntax for translating C code to Fortran.



%\note Code template names are type names and can be used to both specify 
%the concrete syntax of different languages and to specify the data structure that should be used
%to store the input code. For more details, see Section~\ref {sec-codeTemplate}.
%
%\note Xform routines can define optional parameters whose values
%are re-configured inside a pair of $[]$ when the routine is being invoked. For more details,
%see Section~\ref {sec-exp-xformHandle}.

%%%%%%%%%%%%%%%%%%
\section{Program Optimizations}
\label {sec-opt-driver}
%%%%%%%%%%%%%%%%%
Translating between the syntax of different languages is only a small  part of what POET can be used for.
The language was designed to the parameterization and empirical tuning of compiler optimizations, and a large library of optimizations have been provided to support this purpose. 
The interface of these library routines is declared in POET/lib/opt.pi, and their implementations are in POET/lib/opt.pt.
For more details on how to use POET to support compiler optimizations, see additional POET documentations which are downloadable from the POET web page at \url{www.cs.uccs.edu/~qyi/poet/docs.php}.

\paragraph {Optimizing And Tuning Scientific Codes} Qing Yi. In SCALABLE COMPUTING AND COMMUNICATIONS: THEORY AND PRACTICE. Samee U. Khan, Lizhe Wang, and Albert Y. Zomaya. John Wiley\&Sons. 2011.

\paragraph {POET: A Scripting Language For Applying Parameterized Source-to-source Program Transformations.}
Qing Yi. Software Practice \& Experience. Accepted For Publication. 2011. (The article has already been published online since MAY 11, 2011 with DOI: 10.1002/spe.1089).

%%%%%%%%%%%%%%%%%%%%%%%%%%%	
\chapter {Language Overview}
\label {chap-overview}
%%%%%%%%%%%%%%%%%%%%%%%%%%%	

\section {Overview of Concepts}

The following briefly outlines the main concepts that will be covered by this manual. 
\begin {enumerate}
\item {\em Atomic and compound values} (Chapter~\ref{chap-value}).  
POET supports two types of atomic values: {\em integers and strings}; three types of compound data
structures: {\em tuples, lists, and maps}; and one user-defined data type, {\em code templates}. 
It uses a special type, {\em xform handle}, to support function pointers. 


\item {\em Code templates (Chapter~\ref{chap-code}).} 
POET code templates are essentially pointer-based data structures that can 
be used to build arbitrarily shaped trees and DAGs (directed acyclic graphs). 
They are used to build the AST (Abstract Syntax Tree) internal representations of different input 
programs and to support the parsing/unparsing of the input codes.
In particular, code templates are used in the parsing phase to recognize the structure of the input code, 
in the program evaluation phase to represent the internal structure of programs, 
and in the unparsing phase to output results to external files.

\item {\em Xform  routines (Chapter~\ref{chap-xform})}, which are functions that each
takes a number of input parameters  and returns a result. 
POET xform routines can make recursive invocation of each other, 
use loops and if-conditionals to iterate over a body of computation, and systematically
apply transformations and program analyses to the internal representations of various input codes. 
%The emphasis is on full programming support to easily define arbitrary code  transformations.

\item {\em Variables and Assignments (Chapter~\ref{chap-var}).} 
POET uses variables to hold values of intermediate evaluation and to adapt behaviors of
the POET interpreter. Variable assignments can be used to modify variables to contain different values.
However,  they cannot modify the internal content of existing compound data structures. For example,
variable assignment can modify a variable $x$ to contain a new value,
but it cannot modify the content of an old data object contained in $x$, as this object may be
shared by other variables. 

\item {\em Global commands (Chapter~\ref{chap-commands})}, which are declarations and evaluations 
at the global scope of POET programs.
The collection of global commands  are evaluated in the order of their appearance, where each command can use the result of previous evaluations.

%\item {\em Type specifications and pattern matching (Chapter~\ref{chap-pattern}).} 
%POET is a dynamically typed language and provides a collection of type specifiers, 
%one for each type of values supported by the language, 
%to allow the types of expressions to be dynamically tested and to allow different types of values to be 
%converted to each other. 
%The pattern matching operator ($:$) is used to dynamically examine the types of POET values,
%and the =$>$ and ==$>$ operators are used to convert different types between one another.
%
%\item {\em Parsing specifications and type conversion (Chapter~\ref{chap-parse}).}
%POET provides a collection of parsing specifications to specify how to parse a stream of input tokens
%and convert them into an internal structured representation using code template objects. These parsing
%specifications are used inside code template definitions to guide the parsing/unparsing process and are used
%to dynamically convert different types of values from one to another.

\item {\em Expressions  and built-in operations (Chapter~\ref{chap-exp})}.
POET provides a large collection of built-in operators to support different types of expressions,
which are building blocks of  program evaluation. POET expressions must be embedded within
global commands to be evaluated in POET programs.

\item {\em Statements (Chapter~\ref{chap-stmt})}, which are different from expressions in that they 
do not have values.
POET statements serve to provide support for debugging and control flow such 
as sequencing of evaluation, conditional evaluation, loops, and early exit from a xform routines.
\end {enumerate}


The POET/lib directory contains a library of routines for applying various compiler
optimizations and  
a collection of code templates which specialize the xform routines for different programming 
languages such as C.  The transformation libraries are typically named using
the ``.pt"  extension, where their header files (which declare only the interfaces of the libraries)
using the ``.pi" extension. 
The code template files are typically named using the ``.code"  extensions.

%%%%%%%%
\section {Categorization of POET Names}
\label {sec-names}
%%%%%%%%

When the POET interpreter sees an identifier, it categorizes it into one of the following kinds.
\begin {itemize}
\item Code template names, which are names that have been declared as code templates in global declarations. 
If a name, say $MyCode$,  has not been declared,
it must be written as {\it CODE.MyCode} in order to be parsed by the POET interpreter as a code template name.
\item {\it Xform} routine names, which are names that have been declared as xform routines
in previous global declarations. If a name, say $MyRoutine$, has not been declared, it must be written
as {\it XFORM.MyRoutine} to be treated by the POET interpreter as a xform routine name.

\item Global variable names, which are names declared in the global scope.
When a global variable, 
say $MyName$, is used within a local scope (e.g., inside a code template or xform routine body), 
it must be written as $GLOBAL.MyName$ to avoid being
treated as a local variable.

\item Static or local variable names. In POET, variables don't need to be declared before used. Therefore,
unless an identifier has been explicitly declared as a code template name, a xform routine name, or  a global
variable name, it will be treated as a local variable variable if used within a code template/xform routine
and will be treated as a static variable if used in the global scope. 

\end {itemize}
Because a POET program can include multiple files, the ordering of processing different files
may impact how the names in POET file are interpreted. To avoid misinterpreting code template, 
xform routine, and global variable names, these names need to be
properly declared before used in each POET file. 
Alternatively, a proper prefix, $CODE$, {\it XFORM}, or $GLOBAL$, can be used to qualify the use of each 
name.

%%%%%%%%
\section {Components of POET Programs}
%%%%%%%%%

A POET program is comprised of an arbitrary number of different files, where 
each file contains a sequence of global declarations the following kinds.
\begin {itemize}
\item  Include directives, each specifies the name of an external file that should be evaluated before
reading the current file. For example, the following directives are used to
start the POET/lib/Cfront.code file.
\begin {verbatim}
include ExpStmt.incl
include Loops.incl
...
\end {verbatim}
All {\em include} directives must be placed at the start of a POET file, so that all the specified external files are  evaluated before reading the current file.  If a file name with extension $.pi$ is included,  a corresponding library file with the same name but with extension $.pt$ will loaded and evaluated after processing the current file. 
\item Xform routine declarations (see Section~\ref{sec-xform-def}), which define global functions that can be invoked to operate on arbitrary input code. 
\item Global variable declarations(See section~\ref{sec-var-global}), which define global names that 
can be accessed across different POET files.
%as macros to
%modify the default behavior configurations of the POET interpreter, command-line  parameters whose values can be modified via command line options when invoking a POET program, and trace handles which
%can be used to track transformations applied to input code.

\item Code template declarations (see Section~\ref{sec-code-def}), which define global
code template types and their syntax in various source languages.
\item Global commands (see Chapter~\ref{chap-commands}) which define what input computations to parse 
and process, what expressions to evaluate, and what results to output to external files.
\item Comments, which are either enclosed inside a pair of $<$* and *$>$, or from $<$$<$* until the end of
the current line. 
Specifically, all strings enclosed within $<$* and *$>$ are ignored by the POET interpreter, so are
all strings following $<$$<$* until the end of line.
\end {itemize}

Except for the {\em include} directives, which must be placed at the beginning of a POET file, the other POET
global declarations and commands can appear in arbitrary order.
The global declarations serve to specify attributes of global names (e.g., global variables,
code templates and xform routines). In contrast, the global commands  are actual
instructions that are evaluated according to the order
of their appearance in the POET program.
 
As explained in Section~\ref {sec-names}, the ordering of processing global declarations may impact
how different names used in a POET file are interpreted, e.g., as a code template name or a local variable name. 
It is important to note that each POET file is first parsed and saved in an internal
representation before being evaluated. 
Therefore, although the global $input$ command can include external POET files,
the declarations contained in these files are {\em not} visible to the current POET file being processed.
{\em The only way to make visible the global declarations of other files is to use the  include
directives at the beginning of a POET file. }
%Because of this, although the name $TransformCode$ is defined in
%$xformFile$, it needs to be declared in $TranslatorDriver$ as a xform routine name to avoid
%being treated as a regular global variable.

%%%%%%%%%%%
\section {Notations}
%%%%%%%%%%%%
The following notations will be used throughout the rest of this manual 
 when using BNF (Backus-Naur Form)  to specify the context-free grammar of POET.
\begin {itemize}
\item $<$concept$>$, which specifies a non-terminal in BNF. 
Each $concept$ has its own syntax and semantics explained elsewhere.
Examples of concepts include $<$exp$>$ (all POET expressions), $<$type$>$ (all POET
type specifiers).
\item $[ syntax ]$, which specifies  that the appearance of $syntax$ (could be any syntax definition)
is optional. For example, $[ default=$$<$exp$>]$ indicates that the definition of the default value 
(using the $default$ keyword) can be optionally skipped.
\item $\{ syntax \}$, which specifies that the appearance of $syntax$ (could be any syntax definition)
can be repeated arbitrary times (include $0$ times, which means $syntax$ can be optionally skipped).
For example $\{ , <id> [ = $$<$exp$>] \} $ indicates that additional variable initializations (separated by ``,") can appear arbitrary times.
\item $/* comments */$, which is not a part of the BNF but is a comment that explains the
 BNF concept that immediately precedes it.
\end {itemize}
Because the above notations have given $<,>,[,],\{,\}$ special meanings, these characters are quoted with ``" when
they are part of the language syntax.

The following notations are used throughout the manual to specify various components of the POET language.
\begin {itemize}
\item $<$id$>$: all variable names.
\item $<$pos\_int$>$: all positive integer values, e.g., 1,2,3,....
\item $<$type$>$: all POET type specifications, defined in Section~\ref {sec-typeSpec}.
\item $<$pattern$>$: all POET pattern specifications, defined in Section~\ref {sec-pattern}.
\item $<$parse\_spec$>$: all POET parsing specifications, defined in Section~\ref {sec-parseSpec}.
\item $<$exp$>$: all POET expressions, defined in Chapter~\ref {chap-exp}.
\end {itemize}

%%%%%%%%%%%%
\chapter {Atomic and Compound Data Types}
\label {chap-value}
%%%%%%%%%%

POET supports two types of atomic values: integers and strings; three types of built-in compound data
structures: tuples, lists, and associative maps; one user-defined data type: code templates;
and one global function type: xform handles.
POET does not allow the modification of compound data structures such as 
tuples, lists, and code templates, which can be used collectively to
build internal representations of the input computation. The only compound data structure that can be
modified is {\em associative maps}, which cannot be used inside other compound data structures
and therefore do not affect the traversal of program internal representations.
 
\section {Atomic Values}
\label {sec-atomic-value}
POET supports two types of atomic values, integers and strings. 
It does not support floating point values under the assumption that  
code transformation and analysis do not need floating point evaluations.
Like C, POET uses integers to represent boolean values: the integer value $0$ is equivalent to
boolean value $false$, and all the other integers are treated as the boolean value $true$.
It provides two boolean value macros, $TRUE$ and $FALSE$, to denote the corresponding integer values 1 and 0 respectively.

\subsection {Integers}
POET provides built-in support for integer arithmetics ($+$, $-$, $*$, $/$, $\%$), 
integer comparison 
($<$, $<=$, $>$, $>=$, $==$, $!=$), and boolean operations ($!$, $\&\&$ and 
$||$). The semantics of these operations are straightforward 
and follow those of the C language. 
Except for the $==$ and $!=$ operators, which apply to all types of values, 
the other arithmetic and comparison operations are defined for integer values only.
When evaluating boolean 
operations, all input values are converted to integers 
1 and 0,  where
empty strings are converted to 0 and all other non-integer values to 1.

\subsection {Strings}
A string value is defined by enclosing the content within a pair of double quotes, e.g., ``hello", ``123". 
The escaped strings ``$\setminus$n", ``$\setminus$r" and ``$\setminus$t" have the same meanings as those in C.
POET additionally provides a special string, ENDL, to denote line-breaks in the underlying language.

POET treats strings as atomic values and does not allow modifications to the contents of strings. 
It provides a binary operator $\wedge$  to support string concatenation, e.g.,  ``abc"  $\wedge$ 3  $\wedge$  ``def" returns $``abc3def"$ (note that integer operands are automatically converted to strings before used in the concatenation). 
The operator $SPLIT$ can be used to split a string into a list of substrings based on a specified separator. For example, $SPLIT(``,", ``abd,ade")$ returns a list of three strings $(``abd"  ``," ``ade")$.  
It can also be applied to strings contained in compound data structures. For example, 
$SPLIT(``+",  Stmt\#(``a + b +c "))$ returns $Stmt\#(``a" ``+" ``b" ``+" ``c")$. 
If the separator is an integer $n$, the input string is split immediately after the $n$th character of the string.
For example $(SPLIT(1,``abc") = (``a" ``bc")$.

\section{Compound Data Structures}
\label {sec-compound-value}

POET provides three built-in types of compound data structures: lists, tuples, and associative maps.

\subsection {Lists}
\label {sec-list}

A POET list is simply a singly linked list of elements and can be composed by simply listing elements together. 
For example, (a ``$<=$" b) produces a list  with 
three elements, a, ``$<=$", and b. 
A special keyword, $NULL$, is used to denote an empty list, which is equivalent to an internally null pointer. 
The operator $::$ is provided to dynamically extend an existing list.
For example, if $b$ is a list, $a::b$ inserts $a$
into $b$ so that the value of $a$ becomes the first element of the new list.  
If $b$ is $NULL$, then the result is a list that contains a single element, $a$. 

Because lists can be dynamically extended, they can contain an arbitrary number of elements at runtime.
Two operations are provided to access elements in a list $\ell$:
$HEAD(\ell)$ (or $car (\ell)$), which returns the first element of $\ell$
(if $\ell$ is not a list, it simply returns $\ell$);
and $TAIL(\ell)$ (or $cdr (\ell)$), which returns the tail of the list (if $\ell$ is not
a list, it returns $NULL$).
For example, if $\ell$ = ($a$ ``$<=$d'' $3$), then $HEAD(\ell)$ (or $car ( \ell)$) returns $a$,
$HEAD(TAIL(\ell))$ (or $car (cdr (\ell))$) returns ``$<=$'', and 
$HEAD(TAIL(TAIL(\ell)))$ (or $car (cdr (cdr (\ell)))$) returns $3$;
The number of elements in a list may be obtained using the $LEN$ operator.
For example, $LEN(1 2 3) = 3$.

When being unparsed to external files, the elements within a list are 
output  one after another without any space, e.g, a list (``a" ``+" 3) is unparsed
as  ``a+3". 


\subsection {Tuples}
\label {sec-tuple}
A POET tuple is a finite number of elements
and is composed by connecting 
a predetermined number of elements with commas. 
For example, (``i" , 0, ``m" , 1) produces a tuple t with four elements, 
``i",0,``m", and 1. 
Each element in a tuple $t$ is accessed via the syntax $t[i]$, where $i$
is the index of the element being accessed (like C, the index starts from 0).
For example, if $t$ = ($i,0,``m",1)$, then $t[0]$ returns ``i",
$t[1]$ returns $0$, $t[2]$ returns ``m'', and $t[3]$ returns $1$.
Because all elements within a tuple must be explicitly specified when constructing the tuple,
tuples are used to define a finite sequence of 
values, e.g, the parameters for a code template or a {\it xform} routines.
The $LEN$ operator can be used obtain the size of 
a tuple. For example, $LEN(1,3,4,5) = 4$.

When being unparsed to an external file,  elements within a tuple 
are output one after another separated by commas. 

\subsection {Associative Maps}
\label {sec-map}

POET uses associative maps to associate pairs of arbitrary types of values. 
To create an map, use the {\it MAP} operator  followed by a tuple of
entries enclosed within a pair of $\{\}$.  For example, MAP\{\} creates an empty map, 
and MAP\{1 =$>$ 5, 2 =$>$ 6\} creates a map with two entries that map 1 to 5 and 2 to 6 respectively.
The elements within a map can be accessed using the ``[]" operator and modified using assignments. 
For example, if $e$ 
is an associative key inside the map $amap$, then $amap[e]$ returns the mapping result; otherwise, the 
empty string ``" is returned. 
The size of a map $amap$ can be obtained using 
{\it LEN}$(amap)$. All the elements within the map can enumerated using the built-in $foreach$ statement. 
For more details about the $foreach$ operation, see Section~\ref {sec-stmt-foreach}.

Each associate map is internally implemented using C++ STL 
maps, and they are the only compound data structure whose internal content can be dynamically modified.
The following illustrates how to create and operate on associative maps.
\begin {verbatim}
   amap = MAP{};
   amap["abc"] = 3;
   amap[4] = "def";
   bmap = MAP{1 => 5, 2 => 6};
   print ("size  of amap is " LEN(amap)); 
   foreach cur=(from=_, to=_)  \in (amap bmap)  do
       print ("MAPPING " from "=>" to);
   enddo
   print amap;
   print bmap;
\end {verbatim}
The output of the above code is 
\begin {verbatim}
   size  of amap is  2 . 
   MAPPING  4 => "def" 
   MAPPING  "abc" => 3 
   MAP{4=>"def","abc"=>3}
   MAP(1=>5,2=>6}
\end {verbatim}

\section {Code Templates}
\label {sec-codeTemp}

POET code templates are essentially pointer-based data structures and can be
used to build recursive data structures such as dynamically shaped trees and DAGs (directed acyclic graphs). 
To a certain extent, POET code templates are just like C structs, where each code template name
specifies a different type, and each component of the data structure is given a specific field name.
POET uses code templates extensively to build the AST (Abstract Syntax Tree) internal representations of programs for transformation or analysis. POET offers integrated support for associating parsing/unparsing
specifications with each code template (see Chapter~\ref{chap-code}), so that input programs can be automatically parsed,
converted to their internal code template representations, and unparsed with proper syntax.


The syntax for building a code template is 
\begin {verbatim}
<id> # (<exp> {, <exp>})
\end {verbatim}
where $<$id$>$ is a code template name, and each $<$exp$>$ specifies a value for each parameter (i.e., 
each data field) of the code template.
For example, $Loop\#(``i",0,``N", 1)$ and $Exp\#(``abc / 2")$ build objects of the code templates $Loop$ and $Exp$ respectively.  Section~\ref{sec-code-def} presents details on how to define different code template types.


To get the values of data fields within a code template object, use syntax
\begin {verbatim}
<exp>[ <id1> . <id2>]
\end {verbatim}
where $<$exp$>$ is a code template object, $<$id1$>$ is the name of the code template, and
$<$id2$>$ is the name of a template parameter.
For example, $aLoop[Loop.i]$ returns the value of the $i$ data field in $aLoop$, which is an object
of the code template type $Loop$. 
Similarly, $aLoop[Loop.step]$ returns the value of the $step$ field in $aLoop$.
If $aLoop$ is built via $Loop\#(``ivar", 5, 100,1)$, then $aLoop[Loop.i]$ returns value ``ivar",
and $aLoop[Loop.step]$ returns value $1$.

%%%%%%%
\section {Xform Handles}
\label {sec-xformHandle}
%%%%%
Each POET xform handle is a global function pointer. It is similar to a C function pointer except that it
includes not only the global name of a routine but also a number of values for the
optional parameters of the routine.  Similar to C functions,  POET xform routines can be defined
only at the global scope. So each  name uniquely identifies a xform routine. 
POET xform handles can be used as values of variables, which can then later be invoked by 
following it with a tuple of actual parameter values. 
Each xform handle can be defined using the following syntax.
\begin {verbatim}
<id> [ "["<id>=<exp> { ;.<id>=<exp>} "]" ]
\end {verbatim}
Here each
{\it $<$id$>$=$<$type$>$} defines a new value for an optional parameter (name defined by $<$id$>$) 
of the xform routine.
Therefore, optional parameters of an xform routine can be given values before the routine is actually
invoked. 
For example, $ParallelizeLoop[trace\_include=x]$ is a function pointer to the $ParallelizeLoop$ routine, where the 
optional parameter $trace\_include$ of the routine is set to the value of $x$. 
Since a xform handle can be used in arbitrary places where an expression is expected and can be invoked at an arbitrary time in the future, an xform handle can be used to pre-configure behaviors of an
xform routine before it is invoked.
To take advantage of this support,  parameters that can be used to reconfigure the behavior of an {\em xform} routine should always
be defined as optional parameters. Only pure input parameters (parameters that define the input
of the routine) should be declared as required parameters.




%%%%%%%%%%%%%
\chapter {Code Templates}
\label {chap-code}
%%%%%%%%%%%
POET code templates are user-defined data types that can be used to implement arbitrary acyclic data structures.
In particular, they are typically used to implement the internal representation of arbitrary input codes. 
Additionally, they can be associated with syntax specifications that specify 
how to parse an input computation
and how to unparse internal representations to external files. 

\section {Defining Code Templates}
\label {sec-code-def}

The syntax for declaring code templates is
\begin {verbatim}
  "<" code  <id>  [pars = (<id> [: <parse_spec> ] {, <id> [: <parse_spec]}) ]
                  [parse = <parse_spec>]
                  [lookahead = <pos_int>]
                  [rebuild = <exp>] 
                  [match = <type>]
                  [output = <type>]
                  {<id> = <type> } "/>"
\end {verbatim}
or
\begin {verbatim}
  "<" code  <id>  [pars = (<id> [: <parse_spec> ] {, <id> [: <parse_spec]})]
                  [parse = <parse_spec>]
                  [lookahead = <pos_int>]
                  [rebuild = <exp>] 
                  [match = <type>]
                  [output = <type>]
                  {<id> = <type> } ">"
<exp>          /* body of code template*/
"</"code">"
\end {verbatim}
The first format declares the interface of a code template; i.e., the data type name and components of each data object.
The second format
additionally defines the associated concrete syntax of the code template; that is, how to build its internal representation from 
parsing an input file  and how to
unparse the internal representation to external files.

Each code template name uniquely identifies a user-defined data type,  where the template parameters are data fields within the structure.
A code template can be declared an arbitrary number of times.
However, its concrete syntax definition can be encountered only once during each evaluation
of the global parsing/unparsing command (i.e., the $input$ and $output$),  unless the POET interpreter
 is invoked with the command-line option $-md$.
Except the code template name, all the other components of a code template are optional.
The following explains the semantics of each optional component.

\section {Template Parameters}
\label {sec-code-param}
In the following example,
\begin {verbatim}
<code Loop pars=(i,start,stop,step)/>
<code If pars=(condition:EXP) >
if (@condition@)
</code>
\end {verbatim}
the  
 {\it pars=...} syntax specifies the required parameters of the code templates.  Each template 
 parameter is specified either using  a single name or a $<$id$>$ : $<$parse\_spec$>$ pair, which specifies both
the parameter name and how to obtain the parameter value via parsing.
For example, as declared above, the code template $Loop$ has four required parameters: $i$, $start$, $stop$, and $step$; the code template {\it If} has a single parameter, $condition$, which is an expression and can be obtained via parsing by matching the input code against the {\it EXP} type specifier, explained in Section~\ref{sec-typeSpec}.


\section {Template Body}
\label {sec-code-body}

In the following example, 
\begin {verbatim}
<code Loop pars=(i:ID,start:EXP, stop:EXP, step:EXP) >
for (@i@=@start@; @i@<@stop@; @i@+=@step@)
</code>
\end {verbatim}
The list of strings between the pair of $<$code...$>$ and $<$/code$>$ defines the body of the $Loop$ code template.
Each template body is typically a list of strings in a POET input/output language such as C, C++. 
POET expressions,  e.g., the template parameters $i$, $start$, $stop$, and $stop$
in the above example, need to be wrapped inside pairs of  @s within the body to be properly evaluated.


By default, POET uses the bodies of code templates as the basis both for constructing internal
representations of programs from parsing and for  unparsing internal representations
to external files. When trying to parse the tokens of an input program
against a specific code template, the POET  parser first substitutes each 
template parameter
with its declared type  in the code template body (if no type is declared for the parameter,
the $ANY$ type specifier, which can be matched to an arbitrary string,  will be used).  
The substituted  template body is then matched
against the leading strings of the input. 
Whenever a code template type within the template body is encountered,
the POET interpreter tries to match the program input against the new code template.
This strategy essentially builds a recursive-descent parser on-the-fly by interpreting the code template
bodies. Since POET uses recursive descent parsing, the code templates cannot be left-recursive;
that is, the starting symbol in the template body cannot recursively start with the same code template type.
If a left-recursive code template is encountered during parsing evaluation,
segmentation fault will occur as is the case for all recursive descent parsers.

%%%
\section {Template Attributes}
\label {sec-code-attr}
%%
Each code template can include a number of attributes, each defined using syntax
{\it $<$id$>$=$<$type$>$},  where $<$id$>$ is the attribute name,
 and $<$type$>$ specifies the default value of the particular attribute. 
%The values for these attributes can be specified together with the values
%for code template parameters when constructing code template objectsusing the $\#$ operator.
For example, the following code template declaration
\begin {verbatim}
<code Loop pars=(i,start,stop,step)  maxiternum=""/>
\end {verbatim}
specifies a template attribute named $maxiternum$, which remembers the maximal number of
iterations that a loop may take.
%A $Loop$ code template object such as the following\\
%$Loop\#("i",0,m,1)\#100$
%can be constructed which specifies (after the second $\#$ sign) that
%the maximal iteration number of the loop is $100$.

While users can define arbitrary attribute names for a code template, 
 several keywords, including $parse$, $lookahead$, $rebuild$,  $match$, $output$,
 $unparse$, $rebuild$, $parse$, and $output$,  are reserved and 
 are used to specify how to  parse, unparse, simplify, and operate on  
 objects of the code template.
 
 \subsection {The {\it parse} attribute} 
 When the $parse$ attribute is defined, the template body  is no longer used to parse a given input
 and unparse a code template object. 
 Instead, the value of the $parse$ attribute is used.
  %The only difference here is that no local or global variables are allowed in the specification.

A common use for the $parse$ attribute is to specify an alternative xform routine
% which specifies a  {\it xform} routine that should take the parsing responsibility
% for the code template; that is, the $xform$ routine should be used
to convert input tokens to code template objects.  Such xform routines are called {\it parsing functions}.
% As illustrated by the $ParseList$ routine in Figure~\ref{fig-xform}, 
Each parsing function
 must take a single parameter, the $input$ token stream to parse, and return a pair of values
 $(result,leftOver)$, where $result$ is the result of parsing the leading strings in $input$, 
 and $leftOver$ is the rest of the input token stream to continue parsing. 
 A number of commonly used parsing functions are defined in the $POET/lib/utils$.
 
\subsection {The {\it lookahead} attribute}
The POET interpreter uses a recursive descent parser to dynamically match input tokens
against the concrete syntax of code templates.
Since multiple alternative code templates may  be specified to match the input, 
the POET interpreter uses the leading input tokens to determine which code template to choose.
Specifically, if the $lookahead$ attribute is given value $n$ for a code template,  
the next $n$ input tokens is used to determine whether to select the particular code template for parsing.
By default, the value of $lookahead$ is $1$ for all code templates.

\subsection {The {\it match} attribute}
This attribute specifies a set of parent code template types which can be viewed as a base type of the current code template.
During pattern matching operations (see Section~\ref{sec-pattern}), if 
the code template fails to match against a given pattern, the POET interpreter
uses the value of it's $match$ attribute as an alternative target and tries again.
For example, the following code template definition
\begin {verbatim}
<code Loop pars=(i:CODE.Name,start:EXP, stop:EXP, step:EXP) match=CODE.Ctrl />
\end {verbatim}
specifies that the $Loop$ code template can be considered a derived instance of the $Ctrl$ code template and therefore can
match the pattern $CODE.Ctrl$.

\subsection {The {\it rebuild} attribute}  
This attribute specifies an alternative expression that should be used to substitute the resulting 
code template object during parsing or when the REBUILD operator (see Section~\ref {sec-op-xform}) is invoked. 
For example, the following code template definition
\begin {verbatim}
<code StmtBlock pars=(stmts:StmtList) rebuild=stmts>
{
   @stmts@
}
</code>
\end {verbatim}
specifies that after parsing the input computation using the $StmtBlock$ code template, the value
of the template parameter $stmts$ should be returned as result of parsing.
The rebuild expression can use both the template parameters and other attributes and can
invoke existing xform routines to build the desired result. 
The result of evaluating the expression will be returned  as the result of parsing or the result of the REBUILD operator.
 
\subsection {The {\it output} attribute} 
This attribute specifies an alternative expression that should be evaluated when 
a code template object needs to be unparsed to an external file.  By default,  
the template body is used both for parsing and unparsing. However,
for some code templates, this may not be the right choice. For example, the following code template
definition (taken from $POET/lib/Cfront.code$) invokes the $UnparseStmt$ routine to unparse 
all C statements, where a pair of \{ \} is wrapped around a statement block if more than one statements
are unparsed.
\begin {verbatim}
<code Stmt pars=(content:GLOBAL.STMT_BASE) output=(XFORM.UnparseStmt(content)) >
@content@
</code>
\end {verbatim}

\subsection {The {\it INHERIT} attribute}
This attribute is used to remember the previous code template object constructed by the POET recursive descent parser immediately before the current code template is used to match the input token stream.  It can be used within the parse attribute to flexibly satisfy type checking and AST construction needs. 
For example, the following code template definition (from $POET/lib/Cfront.code$)
\begin {verbatim}
<code Else pars=(ifNest) parse=("else" eval(return(CODE.Else#INHERIT))) >
else
</code>
\end {verbatim}
specifies that when parsing an $else$ statement, its {\it ifNest} member should be initialized with the previous code template object, i.e., the {\it true} branch of an {\it if}  statement before the $else$ branch. 

%\subsection {The $cond$ attribute} imposes additional constraints  constructing code templates during parsing;
%that is,  the $cond$ attribute expression must evaluate to $true$ (a non-zero integer) when given
%the values for the code template parameters. The $cond$ expression is evaluated when building 
%code template objects  during parsing. 
%For example, in the following code template definition, the $cond$ expression ensures that the $Name:  $
%code template won't be built with an empty string as content.
%\begin {verbatim}
%< *A marker for names composed of sub-components *>
%<code Name pars=(content) parse=ParseList[continue=is_name]
%           cond=(content!= "")
%           rebuild=IgnoreCodeIfSingle[ignore=STRING;code=Name]>
%@content@
%</code>
%\end {verbatim}

%%%%%%%%%%%%%%%%%%%%%%%
 \section {Parsing Specifications}
 \label {sec-parseSpec}
  
 POET provides a collection of parsing specifiers to guide how to parse a stream of input tokens into 
a structured hierarchy of code template objects.
 These parsing specifiers are used inside code template declarations to specify how to parse each template parameter
(see Section~\ref{sec-code-attr}), inside global variable declarations to specify how to parse each command-line parameter (see Section~\ref{sec-var-param}), 
inside expressions to dynamically convert different types of values from one to another (see Section~\ref{sec-typeConvert}),  
and inside input code annotations to improve the parsing efficiency.

A parsing specifier specifies what targeting data structure should be used to parse and represent
a sequence of input tokens and can take any of the following forms. 
\begin {itemize}
\item  A type specifier defined in Section~\ref{sec-typeSpec}, 
where the leading input token will be converted to the specified value type as the parsing result. 
More details on type conversion can be found in Section~\ref{sec-typeConvert}.

\item The name of a code template. In this case, the leading tokens in the input  are 
 matched against the syntax definition of the given code template; if the matching is successful, the matched tokens are 
 converted to an object of the given code template, and parsing continues with the rest of input tokens;
 otherwise, the parsing fails. 
 
 \item A xform handle which takes a single parameter (the input tokens to parse)
 and returns a pair of two values: $(result, left\_over)$, where $result$ contains the resulting structural representation from parsing the leading tokens of input, and $left\_over$ contains the rest 
 of input after parsing. 
In this case, the xform routine is invoked with input tokens as argument, 
the $result$ from invoking the routine is saved,
 and the parsing continues with the $left\_over$ value returned by the routine invocation.
 
 \item A list of parsing specifiers in the form ($<$parse\_spec1$>$  $<$parse\_spec2$>$ ...... $<$parse\_specn$>$).
 Here the parsing process tries to match each of the parsing specifiers in turn.
If the parsing succeeds, a list of the parsing results is 
constructed, and the parsing continues with the rest of the input.
 
 \item A variable assignment in the form
 $<$id$>$ = $<$parse\_spec1$>$.
 Here the input is parsed against the given $<$parse\_spec1$>$, and the parsing result
 is saved in the given variable $<$id$>$.
  
 \item A {\it tuple} specification in the form
 {\it TUPLE($<$string1$>$ $<$parse\_spec1$>$ ...... $<$string\_n$>$ $<$parse\_spec\_n$>$ $<$string\_n+1$>$)}.
 % Here each $<$string\_1$>$ ... $<$string\_n+1$>$ is a single string constant, and each $<$parse\_spec\_1$>$ ...
 %$<$parse\_spec\_n$>$ is a parsing specification. 
 In this case, the targeting data structure is a tuple of $n$ elements, where 
the input tokens must start with $<$string1$>$, end with the 
  $<$string\_$n$+$1$$>$,  and for each i = 1,...,n, the $i$th tuple element is parsed using $<$parse\_spec\_$i$$>$,
 and the $i$th and $i+1$th elements must be separated by $<$string\_$i$+$1$$>$.
 For example, $TUPLE(``("  INT  ``," INT ``," INT ``)")$ specifies a tuple of three integers, where
 the tuple starts with ``(" and end with $``)"$, and each pair of elements is
 separated with a $``,"$.  The parsing fails if any component does not match.
  
\item A {\it list} specification in the form
{\it LIST($<$parse\_spec\_1$>$, $<$string$>$)}.
Here the targeting data structure is a list of elements, with each element parsed using
$<$parse\_spec\_1$>$,  and each pair of elements separated by $<$string$>$ in the input tokens.
For example, $LIST(INT, ``;")$ specifies a list of integers separated by ``;"s; and {\it LIST(INT,`` ")}
specifies a list of integers separated by spaces.

\item The binary alternative ($|$) operation in the form 
$<$parse\_spec\_1$>$ $|$ $<$parse\_spec\_2$>$.
Here the input tokens are matched against each of the parsing specifiers
in order (if the first one fails, the second one will be tried). 
For example, {\it INT $|$ ID} specifies 
a single integer or an identifier. Note that once the input is successfully matched against
$<$parse\_spec\_1$>$, the parser will not try $<$parse\_spec\_2$>$.
So  the operands of the $|$ operator need be listed in the increasing order 
of their restrictiveness. 
%For example, if we use {\it (STRING $|$ INT) (STRING $|$ INT)} to 
%parse a pair of integer/string values, the input will always be parsed as a pair of strings.
%Specifically, because all integers can be treated as strings, the {\it INT} specifier will never be tried in the
%parsing process.
 \end {itemize}


%%%%%%%%%%%%%%%
 \section {Parsing Annotations}
 \label {sec-parseAnnot}
%%%%%%%%
Based on a collection of  code template definitions, POET 
can invoke its internal top-down recursive descent parser to dynamically parse an arbitrary input language.
%However, the recursive descent parser is interpretative, and the parsing process can be slow,
%especially if backtracking is allowed in the parsing process (backtracking can be turned off
%via macro definitions, see Section~\ref{sec-global-macro}).
The input code can be annotated to speed up  the parsing process.
Annotations can also be used to partially parse fragments of an input code, in which case only those
fragments with annotations are parsed into the desired code template representations,
and the rest of the code is represented as a stream of tokens. 
%In general, the more annotations included in the source input, the shorter time it will
%take the POET interpreter to parse the input code.

The following shows a fragment of input code with parsing annotations \\
(taken from POET/test/gemvATLAS/gemv-T.pt).

{\scriptsize
\begin {verbatim}
/*@; BEGIN(gemm=FunctionDecl)@*/
void ATL_USERMM(const int M, const int N, const int K,
          const double alpha, const double *A, const int lda,
          const double *B, const int ldb, const double beta,
          double *C, const int ldc)
{ 
   int i,j,l;                                                   //@=>gemmDecl=Stmt
   for (j = 0; j < N; j += 1)                                   //@ BEGIN(gemmBody=Nest) BEGIN(nest3=Nest)
   {     
      for (i = 0; i < M; i += 1)                                //@ BEGIN(nest2=Nest)
      {
         C[j*ldc+i] = beta * C[j*ldc+i];                       
         for (l = 0; l < K; l +=1)                              //@ BEGIN(nest1=Nest)
         {
            C[j*ldc+i] += alpha * A[i*lda+l]*B[j*ldb+l];   
         }
     }
   }
}
\end {verbatim}
}
Each POET parsing annotation either starts with ``//@" and lasts until the line break, 
or starts with ``/*@" and ends with ``@*/". The special syntax allows
programmers to naturally treat these annotations
as comments in C/C++ code, so that the source input  is readily accessible for 
other uses. 

POET supports two kinds of parsing annotations.
\begin {itemize}
\item {Single-line annotations.}
A single-line annotation applies to a single line of program source.
It has the format ``$=>$ T", where $T$ is a parsing specification as defined in Section~\ref {sec-parseSpec}.
For example,  the annotation `` int i, j, l;  //@$=>$gemmDecl=Stmt" indicates
that  ``int i, j,l;" is a statement that should be parsed using the $Stmt$
code template, and the result should be stored in the global variable $gemmDecl$.

\item {Multi-line annotations.}
Multi-line annotations are used
to help parse compound language constructs such as functions and loop nests, 
which may span multiple lines of the input code.
Each multi-line annotation has the format ``BEGIN(T)" or ``; BEGIN(T)"
where $T$ is a parsing specification (see Section~\ref{sec-parseSpec}).
If there is a ``;" before the $BEGIN$ annotation, the parsing annotation refers to
the source code immediately following the annotation; otherwise, it starts
from the left-most position of the current line.
For example, the annotation
``for (l = 0; l $<$ K; l += 1) //@ BEGIN(nest1=Nest)"
includes a multi-line annotation which starts from the {\it for} loop.
However, the ``/*@; BEGIN(gemm=FunctionDec) @*/" starts from the following line;
that is,  it does not include source code at the same line as the annotation.
In both cases, the relevant source code in the underlying language is parsed based on
the given parsing specification ($nest1=Nest$ or $gemm=FunctionDecl$), and the parsing
results are saved in the respective global variables.
\end {itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%	
\chapter {Xform Routines}
\label {chap-xform}
%%%%%%%%%%%%%%%%%%%%%%%%%%%	

POET xform routines are global functions that each
takes a number of input parameters  and returns a result. 
They can make recursive function calls of each other, 
use loops and if-conditionals to operate on the internal representation of
 input codes, and systematically
apply transformations based on pattern matching or different program analysis results. 
These xform routines are generic in the sense that
they can be invoked to operate on the internal code template representation  of the input code
 parsed from arbitrary programming languages and thus can be reused
across different input/output languages.
%%%%%%
\section {Xform Routine Declarations}
\label {sec-xform-def}
%%%%%%
The syntax for defining a {\it xform} routine is
\begin {verbatim}
"<" xform  <id>  pars = (<id>[:<type>]{,<id>[:<type>]}) {<id> = <type>} "/>"
\end {verbatim}
 or 
\begin {verbatim}
"<" xform  <id>  pars = (<id>[:<type>]{,<id>[:<type>]}) {<id> = <type>} ">"
<exp>         /* body of xform routine */
"</"xform">"
\end {verbatim}
The first syntax declares the interface of a {\it xform} routine, while the second one 
additionally defines the implementation, i.e., the body,  of the routine.  
Here,  the first $<$id$>$ specifies the name of the {\it xform} routine;  {\it pars=...} specifies the required input parameters of the routine; 
%the optional {\it output=...} specifies that the routine returns a tuple of values; 
and each
{\it $<$id$>$=$<$type$>$} specifies an additional optional parameter (name defined by $<$id$>$) 
 and the default value (defined by $<$type$>$) of the parameter. 
When a {\it xform} routine is invoked, a value must be given for each required parameter (defined
using ``pars=...").  Additional arguments may be supplied to replace the default values of the optional parameters, but they are not required.

The following shows two example xform routine declarations in POET/lib/utils.incl.
\begin {verbatim}
<xform ParseList pars=(input) stop="" continue="" output=(result, leftOver)/>
<xform SkipEmpty pars=(input) >
  for (p_input=input;
     p_input != NULL && ((car p_input) : " "|"\n"|"\t");                       
     p_input=cdr p_input)  {""}
  p_input
</xform>
\end {verbatim}
Here the first declaration of $ParseList$ specifies that the routine takes a single parameter named $input$, 
two optional parameters named $stop$ and $continue$ (both with ``" as their default values),
and produces a tuple of two values as result. 
The names in the output specification serve to document the meaning of each value returned by the routine.
%In particular,  if a  $ParseList$ invocation returns
%$x$ as result, the respective return values
%can be accessed using syntax $x[ParseList.result]$ and $x[ParseList.leftOver]$ respectively.
%The body of the {\it xform} routine must return a tuple that has the same number of values as specified by the $output$ attribute.
%If the output attribute is missing, a single value is returned by the routine. 

\section {Invoking Xform Routines}
\label {sec-xform-invoke}

The syntax for invoking a {\it xform} routine is 
\begin {verbatim}
<exp1> ["["<id1>=<exp2>{; <id2>=<exp3>}"]"] ( <exp4> {, <exp5>} )
\end {verbatim}
Here $<$exp1$>$ is an xform handle (e.g., the name of an xform routine) being invoked, 
$<$id1$>$ and $<$id2$>$ are names of optional parameters of the xform routine, 
and $<$exp2$>$,...,$<$exp5$>$ are values for the xform routine parameters. 
In particular, the list of expressions inside the pair of $()$ are values for the required parameters, while 
values for optional parameters are assigned to their respective parameter names.
For example, the following invocation
\begin {verbatim}
ParallelizeLoop[threads=par;private=nest1_private](nest1)
\end {verbatim}
invokes a xform routine $ParallelizeLoop$ with actual parameter $nest1$ while 
assigning the optional parameter $threads$ with the value of $nest1$, 
and the optional parameter $private$ with $nest1\_private$.

%%%%%%%%%%%%%%%%%%%%%%%
\chapter {Categorization Of Variables}
\label {chap-var}
%%%%%%%

POET variables serve as place holders that can store arbitrary types of values at runtime. 
In particular, they can be categorized into the following different kinds.
\begin {enumerate}

\item {\em Local variables}, whose lifetime span through the body of a single code template 
or a single xform routine definition.

\item {\em Static variables}, whose lifetime span the entire program but can
be accessed only within a single POET file; i.e., their scope is restrained within a single file.

\item {\em Dynamic variables}, whose lifetime span the entire program, 
and they can be dynamically created and operated on
at any point in the program.

\item {\em Global variables}, whose lifetime span 
the entire POET program and can be accessed at any point
across different POET files. 
\end {enumerate}
Each category  is maintained in a separate symbol table distinct from the other categories. 

\section {Local Variables}
The lifetime and scope of each local variable is restricted within a single  code template  or xform routine. 
Local variables are introduced by declaring them as parameters of a code template or xform routine, or by simply using them in the body of a code template or xform routine. 
For example, in the following, 
\begin {verbatim}
<code Loop pars=(i:ID,start:EXP, stop:EXP, step:EXP) >
for (@i@=@start@; @i@<@stop@; @i@+=@step@)
</code>
\end {verbatim}
the variables $i$, $start$, $stop$, and $step$ are local variables of the code template $Loop$.
In the following,
\begin {verbatim}
<xform SkipEmpty pars=(input) >
  for (p_input=input;
     p_input != NULL && ((car p_input) : " "|"\n"|"\t");                       
     p_input=cdr p_input)  {""}
  p_input
</xform>
\end {verbatim}
the variables $input$ and $p\_input$ are local variables of the xform routine $SkipEmpty$.

Code template or {\it xform} routine parameters are given
values when the respective code template is being used to build an object or when the respective
xform routine is invoked to operate on some input.
Other local variables are entirely  contained within code templates or xform routines and are 
invisible to the outside. 
A  storage is created for each local variable when a code template is used in parsing/unparsing
or when an {\it xform} routine is invoked, and the storage goes away when the parsing/unparsing
or the routine invocation finishes. None of the storages is visible outside the respective code template 
or {\it xform} routine.

\section {Static Variables}

Each POET file can have its own collection of static variables, which are used by its
commands (see Chapter~\ref{chap-commands}) to store temporary results and 
to propagate information across different evaluation commands. 
While the lifetime of these static variables span the 
entire program, their scopes are constrained only within a single POET file
avoid naming conflict across different POET files.
Static variables do not need to be declared before used.


\section {Dynamic Variables}
\label {sec-var-dynamic}
These are variables dynamically created on the fly by converting an arbitrary
string to a variable name (for more details, see Section~\ref{sec-typeConvert}). 
Dynamic variables are provided mainly to support
dynamic pattern matching. For example, a list of dynamic variables can be
created to replace all the integers in an unknown expression. The substituted
expression can then be used as a pattern  to match against other expressions
that have a similar structure. Because all dynamic variables are created
in a single symbol table throughout a POET program, naming collision can easily
occur. Therefore it is strongly discouraged to use dynamic variables
for purposes other than dynamic pattern matching, e.g., using dynamic variables
as a way for implicit parameter passing is considered very dangerous. 


%%%%%%%%%%%%%%%%%%%%%%%%%%
\section {Global Variables}
\label {sec-var-global}
%%%%%

These are variables whose lifetime span an entire POET program and can be accessed across different POET files. 
However, each global variable must be explicitly declared in each POET file before being used.
There are three categories of global variables.
\begin {enumerate}
\item {\em Command-line parameters}, which are global 
variables whose values can be redefined via command-line options. 
\item {\em Macros}, which are global variables that can be used to reconfigure the
behavior of the POET interpreter or the POET program being interpreted.
\item {\em Tracing handles}, which are global variables that
can be embedded inside the internal representation of computations to keep track of selected fragments 
as they go through different transformations.  
\end {enumerate}

\subsection {Command-Line Parameters}
\label {sec-var-param}

POET command-line parameters act as the configuration interface of a POET program
and their initial values can be specified via command-line options. 
POET command-line parameters must be declared before used. 
Once defined, they can be directly accessed across different POET files.
To declare a command-line parameter, use the following syntax. 
\begin {verbatim}
"<"parameter <id> type=<type> parse=<parse_spec> default=<exp> message=<string>"/>"
\end {verbatim}
Here $<$id$>$ specifies the name of the variable; $<$type$>$ specifies
the type of its value; 
$<$parse\_spec$>$ specifies how to obtain the value of the variable from parsing command-line options of invoking the POET interpreter; 
$<$exp$>$ specifies the default value of the parameter when the command-line option does not specify an alternative value; and $<$string$>$ is a string literal that documents the meaning of the parameter in the declaration. The following shows several example command-line parameter declarations.
\begin {verbatim}
<parameter NB type=1.._ default=62 message="Blocking size of the matrices" />
<parameter pre type="s"|"d" default="d" 
           message="Whether to compute at single- or double- precision" />
\end {verbatim}
The $NB$ parameter is a single integer that must be greater than or equal to 1 (the special value $\_$ is used to denote an unknown upper bound). Its default value is 62 if not reset by command-line options. 
%So the type of $NB$
%is a range (the $lb$ .. $ub$ specifier), which specifies that  the parameter variable must have the integer type and must be within the lower and upper bound specified 
%by $lb$ and $ub$ respectively. 
%Since the parameter has only a lower bound, 
The $pre$ parameter can have two alternative values. Here the type of the parameter uses the $|$ operator to enumerate all the possible values (``s" or ``d"). The default value of the above $pre$ parameter is string ``d".

The command line option to assign a new value to a POET command-line parameter is $-p$$<$id$>$=$<$val$>$, where $<$id$>$
is the name of the variable, and $<$val$>$ is a string that defines the value of the parameter. If necessary, the given parameter value will be parsed, and the
parsing result checked against the given $<$parse\_spec$>$,  before the final result is 
assigned as value of the parameter.
For example, $-pNB$=$50$ assigns $50$ the new value of the $NB$ parameter.
%The given values for all command-line parameters will be checked against their type specifications to ensure the POET program is correctly invoked. 

%%%%
\subsection {Macros}
\label {sec-var-macro}
POET macros can be used to reconfigure the
behavior of the POET interpreter or the POET program being interpreted. 
The syntax for defining a macro is:
\begin {verbatim}
"<" define  <id> <exp> "/>"
\end {verbatim}
Here $<$id$>$ is the name of the macro, and $<$exp$>$ is a POET expression which defines the value of the macro.
The following shows some example macro declarations.
\begin {verbatim}
<define myVar1 "abc"/>
<define x  5 />
\end {verbatim}
The above macro variables are all user-defined names that do not have any special meaning
to POET.  However, POET does provide some built-in macros that have special meanings
and can be used to  modify the default behavior of the POET interpreter, as discussed in Section~\ref {sec-macro}.

\subsection {Tracing Handles}
\label {sec-traceHandle}

POET tracing handles can be viewed both as global variables (i.e., they can be modified via variable assignments)
and as a special data type as they
 can be embedded inside other data structures to trace transformations to various components of the data structure. 
In particular, 
as various transformations are applied to a compound data structure, the tracing handles embedded within 
can be automatically modified to always contain the most up-to-date values of the respective components, so that
different transformations can be applied independently of each other irrespective of how many other transformations have been applied.

Tracing handles need to be explicitly declared  in each POET file before being used.
The syntax for declaring tracing handles is:
\begin {verbatim}
 "<" trace  <id>[=<exp>]  {,  <id>=<exp> }  "/>"
\end {verbatim}
For example, the following declares a long sequence of global trace handles. 
\begin {verbatim}
<trace gemm,gemmDecl,gemmBody,nest3,nest2,nest1/>
\end {verbatim}

NOTE that when a sequence of tracing handles are declared in a single
declaration,  as illustrated above,  these handles are assumed to be related, and
their ordering in the declaration is assumed to be the same ordering that
they should appear in a pre-order traversal of  the data structure that they are embedded inside.
Therefore only related tracing handles should be declared in a single
declaration, and unrelated handles should be declared separately to avoid confusion.

\section {Reconfiguring POET via Macros}
\label {sec-macro}

POET  provides a number of built-in macros  to  modify the default behavior of the POET interpreter,
specifically the behavior of the internal lexer, parser, and unparser when
used to parse input files and to unparse results to external output files.

\subsection {The TOKEN Macro}
This macro reconfigures the POET internal lexer (tokenizer) when reading files using the 
global $input$ command (see Section~\ref{sec-command-input}).
For example, the following declaration appears in the Cfront.code (the C language syntax) 
file in the POET/lib directory.
\begin {verbatim}
<define TOKEN (("+" "+") ("-" "-") ("=""=") ("<""=") (">""=") ("!""=") 
               ("+""=") ("-""=") ("&""&") ("|""|") ("-"">") ("*""/") 
               CODE.FLOAT CODE.Char CODE.String)/>
\end {verbatim}
This declaration configures the POET interpreter to
replace every pair of  $``+"$ ``+" into a single $``++"$ token, every pair of 
$``-" ``-"$
into $``--"$, and so forth. Additionally, the tokenizer will also recognize the syntax
of code templates $FLOAT$, $Char$, and $String$ as tokens. 
%The {\it CODE.FLOAT} syntax indicates that {\it FLOAT} is the name of a code template,
%even if the code template name has not been explicitly declared.

\subsection {The KEYWORD Macro}

This macro reconfigures the POET internal recursive descent parser when reading files using the 
global $input$ command (see Section~\ref{sec-command-input}).
For example, the following declaration appears in the Cfront.code (the C language syntax) 
file in the POET/lib directory.
\begin {verbatim}
<define KEYWORDS ("float" "int" "unsigned" "long" "char" "struct" "union" 
"extern" "static" "const" "register" "if" "else" "switch" "case" "default" 
"continue" "break" "for" "while" "case")/>
\end {verbatim}
This declaration configures the POET internal parser to treat strings 
``case", ``for", ``if", ``while", etc. as reserved words of the 
language, so that these strings are not treated as regular identifiers; i.e.,
they cannot be matched against the ID or STRING token type during parsing.


\subsection {The PREP Macro}
This macro reconfigures the POET internal recursive descent parser
when reading files using the 
global $input$ command (see Section~\ref{sec-command-input}).
For example, the following declaration appears in the Ffront.code (the Fortran language syntax) 
file in the POET/lib directory.
\begin {verbatim}
<define PREP ParseLine[comment_col=7;text_len=70] />
\end {verbatim}
This declaration configures the POET internal parser to invoke the 
$ParseLine$ routine as a filter of the token stream before starting the parsing process.
In particular, the $ParseLine$ routine filters out meaningless characters
based on their column locations. For example, only characters appearing between
column 7-79 are meaningful characters, and an entire line should be skipped 
if the comment-column is not empty.

\subsection {The BACKTRACK Macro}
This macro can be used to disable backtracking in the POET's internal parser
when reading files using the 
global $input$ command (see Section~\ref{sec-command-input}).
The following declaration from POET/lib/Cfront.code  (the C language syntax)
accomplishes exactly this task.
\begin {verbatim}
<define BACKTRACK TRUE/>
\end {verbatim}
Note that when backtracking is enabled. By default, the POET internal parser uses the first
token of each code template body to  determine which code template to use when multiple
options exist to parse an input code. When multiple code templates start
with the same token, only the first one will be tried. If the syntax of the chosen code template
fails to match the input tokens, the entire parsing process fails. 
As a result, by disabling backtracking, the parsing process becomes faster (because
only one code template will be tried when multiple choices are available) but also more
restrictive (the parsing fails immediately instead of trying out other options). 
Similarly, by enabling backtracking, the parsing is slower, but more likely to succeed.

\subsection {The PARSE Macro}
This macro specifies the top-level start non-terminal used to match the entire input code by 
the POET's internal parser when reading files using the 
global $input$ command (see Section~\ref{sec-command-input}).
For example, 
the following declaration appears in the Cfront.code (the C language syntax) 
file in the POET/lib directory.
\begin {verbatim}
<define PARSE CODE.DeclStmtList/>
\end {verbatim}
This declaration informs the POET interpreter that unless otherwise specified
in the input command, the POET internal parser should use the code template $DeclStmtList$
as the start non-terminal when parsing program input. 


\subsection {The UNPARSE macro}
This macro specifies an additional post-processor of the POET internal unparser when evaluating the $output$ command
(see Section~\ref {sec-command-output}).  
For example, 
the following declaration appears in the Ffront.code (the Fortran language specialization) 
file in the POET/lib directory.
\begin {verbatim}
<define UNPARSE XFORM.UnparseLine/>
\end {verbatim}
This declaration instructs the POET interpreter to invoke the $UnparseLine$ routine (defined in
the POET/lib/utils.incl file) after the POET unparser has produced a token stream to output to
an external file.   The $UnparseLine$ routine takes two parameters: the tokens to output,
and the location (column number) of the current line in the external file. 
It will be invoked with the correct parameters when each token needs to be output to the external file.
The $UnparseLine$ routine will filter the token stream by inserting line breaks and empty spaces as
required by the column formatting requirements of the source language (e.g., Fortran or Cobol).

The UNPARSE macro can also be redefined to contain a code template as value. For example,
the following definition appears in POET/lib/Cfront.code (the C language syntax file).
\begin {verbatim}
<define UNPARSE CODE.DeclStmtList/>
\end {verbatim}
Here the code to output will be treated as an object of the $DeclStmtList$ code template (which inserts
line breaks between different statements) before being unparsed to external files.

\subsection {The Expression Macros}
\label {sec-macro-exp}

POET provides built-in support for parsing expressions so that developers only need to use the {\it EXP} 
parsing specifier to convert a sequence of tokens to an expression. Several macros are provided to define
the accepted terms and operations within an expression, including
\begin {enumerate}
\item EXP\_BASE, which defines all the base terms accepted within an expression.
\item EXP\_BOP,  which defines all the binary operators (in decreasing order of precedence) accepted within an expression.
\item EXP\_UOP, which defines all the unary operators (in decreasing order of precedence) accepted within an expression.
\end {enumerate}
For example, the following declarations are used in POET/lib/Cfront.code (the C syntax file).
\begin {verbatim}
<define EXP_BASE INT|FLOAT|String|Char|CODE.VarRef />
<define EXP_BOP ( ("=" "+=" "-=" "*=" "/=" "%=") ("&" "|") ("&&" "||") 
             ("==" ">=" "<=" "!=" ">" "<") ("+" "-") ("*" "%" "/") ("." "->")) />
<define EXP_UOP ("++" "*" "&" "~" "!" "+" "-" "new")/>
\end {verbatim}

The following additional macros are provided to specify how to construct internal representations of the parsed expressions.
\begin {enumerate}
\item EXP\_CALL, which defines the code template to use to represent a function call within the expression.
\item EXP\_ARRAY, which defines the code template to use to represent an array access within the expression.
\item EXP\_MATCH, which defines all the code template types that can be considered instances of expressions when performing pattern matching.
\item PARSE\_BOP, which defines the code template to use to represent binary operations within the expression.
\item PARSE\_UOP, which defines the code template to use to represent unary operations within the expression.
\item BUILD\_BOP, which defines the xform routine to invoke to rebuild binary operations within an expression.
\item BUILD\_UOP, which defines the xform routine to invoke to rebuild unary operations within an expression.
\end {enumerate}

For example, the following declarations are contained in POET/lib/ExpStmt.incl, which is included by the Cfront.code file.
\begin {verbatim}
<define PARSE_CALL FunctionCall/>
<define PARSE_ARRAY ArrayAccess/>
<define PARSE_BOP Bop/>
<define PARSE_UOP Uop/>
<define BUILD_BOP BuildBop/>
<define BUILD_UOP BuildUop/>
\end {verbatim}
Note that if defined, these macros are also used by the POET interpreter when parsing expressions contained in POET scripts.
Specifically, if the {\it PARSE\_BOP}
is defined, the expression $Bop\#(``abc",3)$ will be returned as the result of evaluating a POET expression $``abc"+3$. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter {Top-Level Commands}
\label {chap-commands}
%%%%%%

At the top level, a POET program can include four different kinds of executable commands, input, condition, evaluation, and output
commands. which serve to parse the input code, check the validity of input parameters, compute the output results,  
and unparse the results to external files.
Each command is evaluated one after another according to their order of appearance in each POET file.

\section {The Input Command}
\label {sec-command-input}

The syntax of the POET input command is
\begin {verbatim}
"<" input [cond=<exp>] [DEBUG=<int>] [syntax=<exp>] [from=<exp>] [to=<exp>] 
          [annot=<exp>] [parse=<parse_spec>] "/>" 
\end {verbatim}
or
\begin {verbatim}
"<" input [cond=<exp>] [DEBUG=<int>] [syntax=<exp>] [from=<exp>] [to=<exp>] 
          [annot=<exp>] [parse=<parse_spec>] ">" 
   <exp>
</input>
\end {verbatim}
Each POET input command specifies a number of input code to be parsed and processed.
The first form specifies that the input code should be obtained by parsing external files, while the second form
includes the input computation (specified by $<$exp$>$) to be parsed inside the body of the input command.
The following describes the semantics of each attribute within the $input$ command.  
\begin {itemize}
\item  $cond=<$exp$>$ specifies a pre-condition that must
be satisfied before reading the input code (if the $cond$ expression evaluates to false, no input will be
read);
In particular, it enforces that the  $input$ command is evaluated only when
$exp$ is evaluated to true.
\item 
$DEBUG=<$int$>$ specifies that the parsing of input code needs to be debugged at a given level 
(defined by the constant integer). In particular, the higher the level is, the more debugging information is output. 
\item
$syntax=<$exp$>$  specifies a list of  POET file names that contain syntax definitions for code templates
required to parse the input;
 A single file name instead of a list of names can also be used.
\item
 $from=<$exp$>$ specifies a list of external file names that collectively contain the input code.
 A single file name instead of a list of names can also be used.
 \item
 $to=<$exp$>$ specifies the name of a global variable that should be
used to stored the parsed input code.
If a special keyword, 
``$POET$", is used in place of a variable name,  the input code will be stored as part of
 the current POET program. 
\item
$annot=<$exp$>$ specifies whether or not to recognize POET annotations in the input code.
By default, the $annot$
has a true value, and the parsing process will recognize and interpret POET annotations within the input code; if $annot$ is explicitly
defined to be false, then POET annotations (if there is any) will be treated as part of the input code.
For details of POET parsing annotations, see Section~\ref {sec-parseAnnot}. 
\item
$parse= <$parse\_spec$>$ specifies what start non-terminal (i.e., the start code template) to use
to parse the input computation. When left unspecified, the value of the macro {\it PARSE} is used as the
parsing target. 
%If specified to be the ANY (i.e., the $\_$) type specifier, the input is parsed as a sequence
%of tokens. 
If specified using
a special keyword, 
``$POET$",  the input code should be parsed as a POET program. 
 For more details on parsing specifications, see Section~\ref{sec-parseSpec}.
\end {itemize}

The following are two example input commands which read  input codes file external files.
\begin {verbatim}
<input from=inputFile to=inputCode syntax=(inputLang)/>
<input from=xformFile cond=(xformFile!="") parse=POET />
\end {verbatim}
In the first example, the file name that contains the input code is contained in a global variable $inputFile$, 
the file name that contains syntax definitions of the input language is contained in a global variable $inputLang$, 
and the parsing result will be saved as the value of global variable $inputCode$. 
In the second example, the file named contained in $xformFile$ is parsed iff 
$xformFile!=``"$, and the parsing result will be parsed as a POET program.

\section {The Condition Command}
\label {sec-command-cond}

The syntax of the POET condition command is
\begin {verbatim}
"<" cond <exp> "/>"
\end {verbatim}
This command evaluates the value of the boolean expression $<$exp$>$, which serves to declare constraints among values of global variables that must be true for the POET program to be correct. The program continues as usual if $<$exp$>$ evaluates to $true$ and abort the whole evaluation with an error message otherwise. 

\section {The Evaluation Command}
\label {sec-command-eval}

The syntax of the POET evaluation command is
\begin {verbatim}
"<" eval <exp>  "/>"
\end {verbatim}
This command triggers $<$exp$>$, which is a POET expression or a sequence of statements defined in chapters~\ref {chap-exp}
and~\ref{chap-stmt}, to be evaluated. 
{\bf All POET expressions and statements must be embedded within an eval command to be evaluated at the
global scope.}


\section {The Output Command}
\label {sec-command-output}
The syntax for the POET output command is
\begin {verbatim}
 "<" output  [cond=<exp>] [syntax=<exp>] [from=<exp>] [to=<exp>] "/>" 
\end {verbatim}
Each POET $output$ command unparses the internal representation of a computation to an external file or standard output. 
Here  each $<$exp$>$ represents a POET expression. 
The following defines the semantics of each attribute specification.   
\begin {itemize}
\item  $cond=<$exp$>$ specifies a pre-condition that must
be satisfied before performing the unparsing task (if the $cond$ expression evaluates to false, no result will be unparsed);
\item
$syntax=<$exp$>$  specifies a list of  POET file names that contain syntax definitions 
required to unparse the result;
 A single file name instead of a list of names can also be used.
 \item
 $from=<$exp$>$ specifies the resulting computation that should be unparsed to an external file (or $stdout$).
\item
 $to=<$exp$>$ specifies the name of an external file to output the specified computation.
\end {itemize}
 The following are two examples demonstrating the use of the output command.
\begin {verbatim}
<output cond=(inputLang=="") to=outputFile from=inputCode/>
<output cond=(inputLang!="") syntax=inputLang to=outputFile from=inputCode/> 
\end {verbatim}
Here the code contained in $inputCode$ is unparsed to the file whose name is defined by $outputFile$. 
The file names that contain the syntax definitions of the output language are contained in the global variable $inputLang$.
If an empty string is specified as the output name (or when no name is specified), the resulting computation
will be unparsed to standard output.

%%%%%%%%%%%%%%%%%%%%%%%%%%%	
\chapter {Expressions}
\label {chap-exp}
%%%%%%%%%%%%%%%%%%%%%%%%%%%	

POET expressions are the building blocks of all evaluations
and could take any of the following forms.
\begin {itemize}
\item Atomic values, which include integers and strings. POET use integers to represent boolean values.
\item Compound data structures, which include lists, tuples, associative maps, and code template objects.
\item {\it Xform} handles, which are similar to global function pointers in C. 
\item Variables, which are place holders for arbitrary types of values.
\item Invocation of POET {\it xform} routines, which are essentially calls to global functions.
\item Invocation of built-in POET operators, including both arithmetic operations and other 
operations provided to support efficient code transformation.
\end {itemize}
Except for variables and associative maps, none of the other POET compound data structures can be modified.
Transformations are performed by constructing new values to replace the old ones.
POET provides a large collection of built-in operators, each of which takes a number of input values, performs
some internal evaluation, and returns a new value as result. These operations can be separated into the following categories.


\section {Debugging Operations}
POET provides the following operations to support debugging and error reporting. These operations produce side effects by printing out information and exiting the program if necessary.
\subsection {The PRINT (print) operator} 
\label {sec-op-PRINT}
The syntax of invoking the PRINT operator is
\begin {verbatim}
PRINT <exp> 
\end {verbatim}
or
\begin {verbatim}
print <exp>
\end {verbatim}
The PRINT or print operator takes an arbitrary expression $<$exp$>$, prints out the value of $<$exp$>$ to standard error, and returns an empty string ``" as result. 
It can be used to print out the value of an arbitrary expression for debugging purposes. 
The following shows some examples of using the {\it PRINT (print)} operator.
\begin {verbatim}
print("x=" x);
PRINT("Warning: cannot resolve " cur_sub "-" cpstart 
             ": permuteDim=" permuteDim "; left_offset = " left_offset);
\end {verbatim}

\subsection {The DEBUG operator} 
\label {sec-op-DEBUG}
The syntax of invoking the DEBUG operator is
\begin {verbatim}
DEBUG ["["<int>"]"] "{" <exp> "}"
\end {verbatim}
The DEBUG operator takes an arbitrary expression $<$exp$>$ and prints out debugging
information for evaluating $<$exp$>$ to standard error and then 
returns the result of evaluating $<$exp$>$. 
The $<$int$>$ is used to control how many levels of {\it xform} routine
invocations to debug. By default, $<$int$>$ is one, which means {\it xform}
invocations will be treated as a built-in operators in debugging. If $<$int$>$
is 2, then the debugger will step into each {\it xform} invocation once.
The following shows some examples of using the {\it DEBUG} operator.
\begin {verbatim}
DEBUG {x = 56;}
DEBUG [3] {UnrollLoops(inputCode)}
\end {verbatim}

\subsection {The ERROR Operator}
The syntax of invoking the ERROR operator is
\begin {verbatim}
ERROR  <exp>
\end {verbatim}
The ERROR operator takes an arbitrary expression $<$exp$>$
and prints out the value of  $<$exp$>$ as an error message to inform the user what has gone wrong before  quitting the entire POET evaluation. A line number and the file name that contains the ERROR invocation are also printed out to inform the location that the error has occurred.
The ERROR operator therefore should be 
invoked only when an erroneous situation has occurred and the POET program needs to exit. 
The following shows some examples of using ERROR operator.
\begin {verbatim}
ERROR( "Expecting input to be a sequence: " input);
ERROR( "Cannot fuse different loops: " curLoop " and " pivotLoop);
\end {verbatim}

\section {Generic comparison of values}
\label {sec-op-generic}
\subsection {The == and != operators} 
The syntax of invoking these binary operators are
\begin {verbatim}
<exp1> == <exp2>
<exp1> != <exp2>
\end {verbatim} 
Both operators take two expressions, $<$exp1$>$ and $<$exp2$>$, and 
return a boolean (integer) value indicating whether the two operands are equal or not equal respectively. 

\subsection {Integer and String comparison}
Four binary operators, including $<$, $<=$, $>$, and $>=$, are provided to support the partial ordering 
of integer and string values. 

\section {Integer arithmetics} 
POET integer arithmetic operations include the following binary operators: +, -, *, /, \%, +=, -=, *=, \%=;
and a single unary operator: -.  
These operators have the same meanings as those in C.

\section {Boolean operations} 
POET provides two binary operators,  $\&\&$ and $||$, to support the conjunction and disjunction
of boolean values respectively. It provides  a single unary operator, $!$, to support the 
inversion of boolean values.

\section {String operations} 

\subsection {The concatenation $\wedge$ operator}
It applies to two operands, each of which is a string, an integer,  or a list of strings and integers, and compose the operands into a single string.
For example,   ``abc"  $\wedge$ 3  $\wedge$  ``def" returns $``abc3def"$.
Note that integer operands are automatically converted to strings when used in the concatenation.
The $\wedge$ operator can also be applied to a list of strings, e.g. (``abc"  ``def") $\wedge$ 3 returns ``abcdef3".

\subsection {The $SPLIT$ operator}
The syntax of invoking the $SPLIT$ operator is
\begin {verbatim}
SPLIT "("<exp1> ","  <exp2>")"
\end {verbatim}
Here $<$exp2$>$ is an arbitrary input expression that may contain strings, and $<$exp1$>$ is 
either a string that specifies the separator that should be used to split the strings in $<$exp2$>$,
or an integer that specifies how many characters to count before splitting $<$exp2$>$ into two substrings. 
If $<$exp1$>$ is an empty string, the POET internal tokenizer (lexical analyzer) will be invoked to split
the given string. 
The operation returns a list of  substrings obtained from splitting $<$exp2$>$.
For example, 
\begin {verbatim}
SPLIT(1,"abc")        <<* result is "a" "bc"
SPLIT(",","bc,ade,lkd")      <<* result is "bc" "," "ade" "," "lkd" NULL
SPLIT("", "3,7+5")    <<* result is "3" "," 7 "+" 5 NULL 
\end {verbatim}

\section {List operations} 
\label {sec-op-list}

\subsection {List construction} 
$List$ is the most commonly used data structure in POET. Building a list simply requires that the components be placed together one after another. 
For example,  {\it (1 2 3)} builds a list that contains three elements: 1, 2, and 3.

\subsection {The Cons Operator (::) }
The syntax of invoking the $::$ operator is
\begin {verbatim}
<exp1> :: <exp2>
\end {verbatim}
Here the operator returns a new list that 
inserts $<$exp1$>$ before all elements in $<$exp2$>$.
For example,  $``<=" :: b$ produces a list with 
``$<=$" and elements from b.
If $b$ is $NULL$ (the empty list), the result is a list that contains a single element;
If $b$ is a list, the result contains all elements in b; otherwise, the resulting list  
contains two elements, $``<="$ and $b$. 

\subsection {List Access (The $car/HEAD$, $cdr/TAIL$, and {\it LEN} operators)}
Elements in a list are accessed through two unary operators: $car$ (also known as {\it HEAD})
and $cdr$ (also known as {\it TAIL}). The keywords $car$ and {\it HEAD} can be used interchangeably,
so can $cdr$ and {\it TAIL}.
The syntax of invoking the $car$ and $cdr$ operators are
\begin {verbatim}
car <exp>
cdr <exp>
\end {verbatim}
Here the $car$ operator returns the first element of the list $<$exp$>$; 
if $<$exp$>$ is not a list, it simply returns $<$exp$>$.
The $cdr$ operator returns the tail of the list; if $<$exp$>$ is not
a list, it returns $NULL$.
The following are some examples illustrating the use of these operators.

\begin {verbatim}
a1 = (3 4 5)    <<* returns 3 4 5 NULL
a2 = (1 2 a1)    <<* returns 1 2 (3 4 5 NULL) NULL
a3 = (1 2) :: a1  <<* returns (1 2 NULL) 3 4 5 NULL
a4 = 1 :: 2 :: a1 <<* returns 1 2 3 4 5 NULL
HEAD(a2)        <<* returns 1
TAIL(a2)        <<* returns 2 (3 4 5 NULL) NULL
HEAD(a3)        <<* returns 1 2 NULL
TAIL(a3)        <<* returns 3 4 5 NULL
 \end {verbatim}
 
 The syntax of invoking the {\it LEN} operator is
 \begin {verbatim}
 LEN <exp>
 \end {verbatim}
When given a list as operand, the {\it LEN} operator returns the number of elements within the list. 
For example, {\it LEN(2 3 7)} returns 3, {\it LEN(2 7 ``abc" ``")}  returns 4.


\section {Tuple operations} 
\subsection {Tuple Construction (the ``," operator)}

A tuples is composed by connecting 
a predetermined number of elements with commas. 
For example, ``i" , 0, ``m" , 1 produces a tuple t with four elements, 
``i", 0, ``m", and 1. 
All elements within a tuple must be explicitly specified when constructing the tuple,
so tuples cannot be built dynamically (e.g., using a loop).

\subsection {Tuple Access (The $[]$ and $LEN$ operators)}
Tuples provide random indexed access to their elements.
Each element in a tuple $t$ is accessed by invoking $t[i]$, where $i$
is the index of the element being accessed (like C, the index starts from 0).
For example, if $t$ = ($i,0,``m",1)$, then $t[0]$ returns ``i",
$t[1]$ returns $0$, $t[2]$ returns ``m'', and $t[3]$ returns $1$.

When given a tuple as operand, the $LEN$ operator returns the number of elements within the tuple. For example, $LEN(2,3,7) = 3$, $LEN(2, (``<" 3), 4) = 3$.

\section {Associative Map Operations} 

\subsection {Map Construction (the {\it MAP} Operator)}
POET uses associative maps to associate pairs of arbitrary types of values. 
The syntax of building an associative map using the {\it MAP} operator is the following.
\begin {verbatim}
MAP "(" <type1> , <type2> ")"
\end {verbatim}
or 
\begin {verbatim}
MAP "{" [ <exp1> "=>" <exp2> {"," <exp3> "=> <exp4>} ] "}"
\end {verbatim}
Here $<$type1$>$ and $<$type2$>$ are two type specifiers as defined in Section~\ref {sec-typeSpec}, and 
$<$exp1$>$,...,$<$exp4$>$ are expressions. 
The first form returns a new empty table that maps values of $type1$ to values of $type2$,
while the second form returns a new table with a number of pre-specified entries mapping $<$exp1$>$ to $<$exp2$>$, etc.

\subsection {Map Access (the $[]$ and $LEN$ operators)}

The elements within an associative map can be accessed using the ``[]" operator and modified using the assignment operator (i.e., $=$). 
The following illustrates how to create and operate on maps.
\begin {verbatim}
   amap=MAP(_,_);
   bmap=MAP{"abc"=>3,"def"=>4};
   cmap=MAP{};
   amap["abc"] = 3;
   amap[4] = "def";
   abc = amap["abc"];

   LEN(amap) ;
   foreach cur=(from=_,to=_) \in amap do
       (from) "=>" (to);
   enddo
\end {verbatim}
If a value $e$ is stored as a key in a map $amap$, then $amap[e]$ returns the value associated with $e$ in $amap$; otherwise, an empty string is returned. 
The size of a map $amap$ can be obtained using 
$LEN(amap)$. All the elements within a map can enumerated using the built-in $foreach$ statement. For more details about the $foreach$ statement, see Section~\ref {sec-stmt-foreach}.  

\section  {Code Template Operations} 
\label {sec-op-code}
\subsection {Object Construction (the $\#$ operator)}
POET treats each code template name as a unique user-defined type, where the template parameters are treated as data fields within the structure. To build an object of a code template, use the following syntax.
\begin {verbatim}
<id> "#" (<exp1>, <exp2>, ..., <expn>)
\end {verbatim}
where $<$id$>$ is the code template name. 
For example, $Loop\#(``i",0,``N", 1)$ and $Exp\#(``abc / 2")$ build objects of two code templates named 
$Loop$ and $Exp$ respectively.
 
 \subsection {Code Template Access (the $[]$ operator)}
 To get the values of individual data fields stored in a code template object, use syntax
\begin {verbatim}
<exp>[ <id1> . <id2>]
\end {verbatim}
where $<$exp$>$ is a code template object, $<$id1$>$ is the name of the code template type,
and $<$id2$>$ is the name of the data field (i.e., the name of the code template parameter) to be accessed. 
For example, $aLoop[Loop.i]$ returns the value of the $i$ data field  in $aLoop$, which is a variable that contains a $Loop$ code template object. 
Similarly, $aLoop[Loop.step]$ returns the value of the $step$ field in $aLoop$.
If $aLoop$ contains value $Loop\#(``ivar", 5, 100,1)$, then $aLoop[Loop.i]$ returns value ``ivar",
and $aLoop[Loop.step]$ returns value $1$.

\section {Variable Operations}
\label {sec-op-var}
\subsection {Variable Assignment (the ``=" operator)}
\label {sec-op-assign}

All POET variables can be modified via the assignment operator using the following syntax.
 \begin {verbatim}
 <lhs>  = <exp>
 \end {verbatim}
 Here $<$exp$>$ is an arbitrary expression, and $<$lhs$>$ has one of the following forms.
 \begin {itemize}
 \item A single variable name. In this case,  the value of the $<$exp$>$ is assigned to $<$lhs$>$.
 \item A compound data structure (e.g., a list, tuple, or code template) that contains variables as components.
 In this case, the value of the $<$exp$>$ is matched against the structure of the $<$lhs$>$,
 and all the variables within $<$lhs$>$ are assigned with the necessary values to make the matching successful. 
%In contrast to the pattern matching operator,  all variables in $<$lhs$>$ are treated as uninitialized place holders in the assignment operation, and 
If the value of $<$exp$>$ fails to match the structure in $<$lhs$>$, the evaluation exits with an error. 
 \end {itemize} 
 For example, after the following two assignments,
  \begin {verbatim}
     a = Stmt#input;
    Stmt#a = a;
 \end {verbatim}
 the variable $a$ should have the same value as $input$.
 
 \subsection {Un-initializing Variables (The CLEAR operator)} 
\label {sec-op-clear}
%The {\it CLEAR} operator is invoked to reset an variable so that the variable become uninitialized. 
The syntax of invoking the {\it CLEAR} operator is
\begin {verbatim}
CLEAR <id>
\end {verbatim}
where $<$id$>$ is the name of a variable. The operation clears
the value contained in $v$ so that $v$ becomes uninitialized after the operation. The {\it CLEAR} operator is provided to support pattern matching, where un-initialized variables are treated as place holders that can be matched against arbitrary components of a compound data structure (see Section~\ref{sec-pattern}).


%%%%%
\section {Type Expressions}
\label {sec-typeSpec}
%%%%

Since POET is a dynamically typed language, the types of variables often need to be 
dynamically checked to determine what operations could be applied to them.  
POET provides a collection of type specifiers, one for each type of atomic and compound values, 
to allow the types of expressions to be dynamically tested using pattern matching.
Each type specifier can take any of the following forms.
\begin {itemize}
\item {The ANY (\_) Specifier}, which 
uses a single underscore ($\_$) character  to denote the universal type that includes all values supported by POET. 

\item  A code template name, which includes all objects of the particular code template.

\item {The {\it INT} specifier}, which specifies the atomic integer type and includes all integer values.

\item{The {\it STRING} specifier}, which specifies the atomic string type and includes all string values. 

\item{The {\it ID} specifier}, which specifies the identifier type and includes all string values that start with 
a letter (`A'-`Z',`a'-`z') or the underscore (`\_') character and are composed of letters, the underscore (`\_') character, and integer digits. 

\item {The {\it TUPLE} Specifier}, which  specifies the tuple type and includes all POET tuple.

\item {The {\it MAP} Specifier}, which denotes the associative map type and includes all POET maps.
It can optionally take two parameters to indicate the types of element pairs within the map.  
Specifically, {\it MAP}$(fromType,toType)$ includes all associative maps that associate values of $fromType$ to values of $toType$. %For example, {\it MAP}$(\_,\_)$ includes all maps that may contain arbitrary types of values.

\item {The {\it CODE} Specifier}, which specifies the code template type and includes all code template objects. 

\item {The {\it XFORM} Specifier}, which specifies the xform type and includes all {\it xform} handles. 

\item {The {\it VAR} specifier}, which specifies the $variable$ type and includes all tracing handles as values.

\item {The {\it EXP} Specifier}, which specifies the expression type and includes all POET expressions. 


\item {The range Specifier} $lb .. ub$, where $lb$ and $ub$ are integer values or the {\it ANY} ($\_$) specifier,  
is a {\it range} type and  includes all integers $>= lb$ and $<=ub$.
%For example, $3..7$ includes all integers $>=3$ and $<=7$; $1..\_$ and $\_..1$ include all integers $>=1$ 
%and $<=1$ respectively (here 
If the {\it ANY} ($\_$) specifier is used as the lower or upper bound, it indicates an infinity bound.

\item ($<$type\_1$>$,$<$type\_2$>$,......,$<$type\_n$>$), which specifies a tuple of
$n$ elements, where the type of the $i$th element (i = 1,...,n) is specified by $<$type\_i$>$.

\item ($<$type\_1$>$ $<$type\_2$>$ ...... $<$type\_n$>$), which specifies a list of
$n$ elements, where the type of the $i$th element (i = 1,...,n) is specified by $<$type\_i$>$.

\item $<$id$>$ \# $<$type$>$, which specifies a code template type with $<$id$>$ as the code template
name and  $<$type$>$ as types of template parameters.

\item $<$type\_1$>$ :: $<$type\_2$>$, which specifies a list type with the type of the first element
specified by $<$type\_1$>$ and the rest of the list specified by $<$type\_2$>$.

\item $<$type\_1$>$..., which specifies the $list$ type with $<$type\_1$>$ as the type of all elements within the list. 
As a special case, $(\_...)$ specifies lists that may contain arbitrary elements. Note that an empty list is a value of 
the $<$type\_1$>$... type.

\item $<$type\_1$>$...., which is identical to $<$type\_1$>$... except that it does not include the empty list.

\item $<$type\_1$>$ + $<$type\_2$>$, $<$type\_1$>$ - $<$type\_2$>$, $<$type\_1$>$ * $<$type\_2$>$,
$<$type\_1$>$ / $<$type\_2$>$, and $<$type\_1$>$ \% $<$type\_2$>$, which specify
expression types composed of the binary operators $+$, $-$, $*$, $/$, and  $\%$ respectively. 

\item  $<$type\_1$>$ $|$ $<$type\_2$>$, which specifies the union of two types, $<$type\_1$>$  and $<$type\_2$>$. 
In particular, it includes all values that belong to either $<$type\_1$>$ or $<$type\_2$>$.

\item $\tilde{}$ $<$type\_1$>$, which specifies the complement of $<$type1$>$; that is, it includes all values that do not belong
to $<$type\_1$>$. 

\end {itemize}

%%%%%%
\section {The Pattern Matching Operator (the ``:" operator)}
\label {sec-pattern}
%%%%%%%%
 The syntax of invoking the pattern matching operator is
\begin {verbatim}
 <exp> ":" <pattern>
\end {verbatim}
which determines whether or not an arbitrary expression $<$exp$>$ has a given type.
POET uses pattern matching to dynamically test the type and structure of arbitrary unknown values.
Further, uninitialized variables can be used to save the structural information (component values) 
of the data of interest during the process.
The operation returns TRUE (integer 1) if $<$exp$>$ matches the pattern specified
and returns FALSE (integer 0) otherwise.  
The pattern specifier $<$pattern$>$ may be in any of the following forms.
\begin {itemize}

\item A constant value (i.e., an integer or a string literal), where pattern matching succeeds if $<$exp$>$ has the given value.

\item A type specifier that could have any of the forms defined in Section~\ref {sec-typeSpec}.
Here the pattern matching succeeds only if $<$exp$>$ has the specified type.
 
\item An uninitialized variable name or an operation in the following format,
\begin {verbatim}
CLEAR <id>
\end {verbatim}
where $<$id$>$ is a variable name which is reset by the CLEAR operator to become uninitialized (see Section~\ref{sec-op-clear}).
The pattern matching always succeeds by assigning  the unitialized variable with the value of $<$exp$>$.
Note that the {\it CLEAR} operator typically needs to be applied to all pattern variables if the pattern matching operation is inside a loop, because all uninitialized variables become initialized after the first successful pattern matching.
 
\item The name of an already initialized variable. The pattern matching succeeds if $<$exp$>$ has the same value as the value of the variable, and fails otherwise.

\item A compound data structure, e.g., a list, a tuple, or a code template, that contains other pattern expressions as components. The pattern matching succeeds if $<$exp$>$ has the specified data structure and its components can be successfully matched against the sub-patterns. 
For example, $<$exp$>$ can be successfully matched to {\it (pat1 pat2  pat3)} if it
is a list with three components, each of which can be matched to $pat1$, $pat2$, and $pat3$ respectively.  

\item A $xform$ handle, in which case the handle is invoked with $<$exp$>$ as argument,
and the matching succeeds  if the invocation returns TRUE (a non-zero integer). This feature
allows a function to be written to perform complex pattern matching tasks, and the function can be
used as a pattern specifier in all pattern matching operations. 

\item An assignment operator in the format of $<$id$>$ = $<$pattern$>$, where $<$id$>$ is a single variable name, and $<$pattern$>$ is a pattern specification. Here the pattern matching succeeds if $<$exp$>$ can be successfully matched against $<$pattern$>$; and if successful, the variable $<$id$>$ is assigned with the value of $<$exp$>$.

\item Two pattern specifiers connected by the binary $|$ operator, in the format of \\
$<$pattern1$>$ $|$ $<$pattern2$>$. \\
Here the pattern matching succeeds if $<$exp$>$
could be matched to either $<$pattern1$>$ or $<$pattern2$>$. 
%For example, $(exp  : INT | STRING)$ returns TRUE if $exp$ is either an integer or a string value. 
\end{itemize}
The following illustrates the results of  applying pattern matching to check the types of various expressions. 
\begin {verbatim}
       "3" : STRING                            <<* returns 1
       3 : STRING                              <<* returns 0
       "3" : ID                                <<* returns 0
       "A3" : ID                               <<* returns 1
       MyCodeTemplate#"123" : STRING           <<* returns 0
       MyCodeTemplate#123 : MyCodeTemplate     <<* returns 1
       3 : MyCodeTemplate                      <<* returns 0
       MyCodeTemplate#123 : MyCodeTemplate#INT <<* returns 1      
       ("abc" "." "ext") : STRING              <<* returns 0
       ("3" "4" "5") : (INT ....)               <<* returns 1
       3 : (INT ...)                           <<* returns 0 
       (3 4 5) : (INT ...)                     <<* returns 1
       (3 4 5 "abc") : (INT ...)               <<* returns 0
       (3 4 5 "abc") : (_ ...)                 <<* returns 1
       3 : (0 .. 2)                            <<* returns 0
       3 : (0 .. 5)                            <<* returns 1
       "a" : (0 .. 5)                          <<* returns 0
       "a" : CODE                              <<* returns 0
       MyCodeTemplate : CODE                   <<* returns 1
       MyCodeTemplate#123 : CODE               <<* returns 1
       ("abc" "." "ext") : CODE                <<* returns 0
       MyCodeTemplate#123 : XFORM              <<* returns 0
       ("abc" "." "ext") : XFORM               <<* returns 0
       foo : XFORM                      <<* returns 1; here foo is a xform routine
       "abc" : TUPLE                           <<* returns 0
       ("abc",2) : TUPLE                       <<* returns 1
       MyCodeTemplate#123 : TUPLE              <<* returns 0
       
       
\end {verbatim}

%In summary, a pattern specification  may contain arbitrary type expressions  as components
%and may additionally contain uninitialized variables. For example,
%\begin {verbatim}
%(2 3 4) : (first=INT second third)  <<* returns 1;  first =2; second = 3; third = 4  
%\end {verbatim}
%Here  during the pattern matching evaluation, the uninitialized variables ($second$ and $third$) are
%assigned with the necessary values in order to make the matching succeed.
%Further, since the assignment $first=INT$ is inside the pattern specification, the left-hand side
%of the assignment  (i.e., the $first$ variable) is given the value of the matched expression.

%Note that when uninitialized variables appear in the pattern specification, 
%these variables are treated as place holders which can be matched to
%arbitrary expressions. If the matching is successful, all the uninitialized
%variables are assigned valid values as part of the evaluation. Therefore the pattern matching
%operation can be used not only for dynamic type checking, but also for initializing
%variables and for assigning values to variables (initialized or uninitialized).

  %%%%%%%%%%%%%%
 \section {Type Conversion (The $=>$ and $==>$ Operators)}
 \label {sec-typeConvert}
 %%%
 POET uses two operators ($=>$ and $==>$ operators) to convert a
 value from one type to another.    The syntax of invoking the operators is
 \begin {verbatim}
 <exp>  =>   <parse_spec>
 <exp>  ==>  <parse_spec>
 \end {verbatim}
Both the $=>$ and $==>$ operators have similar semantics in that they both take the given input $<$exp$>$ , parse it 
against the structural definition contained in $<$parse\_spec$>$, and store the parsing result into the 
variables contained in $<$parse\_spec$>$. 
The difference between the $=>$ and $==>$ operators is that when parsing fails, the $=>$ operator reports a runtime error, while the $==>$ operator simply returns {\it FALSE} (the integer 0) as result of evaluation. Therefore the $==>$ operator can be used to experiment with parsing an input expression using different type specifiers.  

For example, $exp => (var = INT)$ converts the value contained in $exp$ to an integer and
 saves the integer value to variable $var$. 
 Note that here the type conversion succeeds only if
 $exp$ can be successfully converted to an integer; a runtime error is reported otherwise.
 In contrast, $exp ==> (var=INT)$ returns false if the conversion fails.
Similarly, $exp => (var =STRING)$ can be used to convert an arbitrary expression to a single string.
Note that all values can be converted to a string or the name of a variable, 
so all expressions can be successfully converted to the {\it STRING} or {\it VAR} type specifier.
The following shows some examples of string conversion.
\begin {verbatim}
3 => STRING                    <<* returns  "3"
MyCodeTemplate#123 => STRING   <<* returns  "MyCodeTemplate#123"
\end {verbatim}
Similarly, when an input value is converted to {\it VAR} parsing specifier,
it is first converted to a string, and the string is then used as the name to 
create a dynamic variable on the fly. 
For example, $5=>VAR$ returns a new dynamic variable that has an internal name created from the number $5$. 
The {\it VAR} parsing specifier therefore allows place-holder variables to be dynamically  created for convenient pattern matching. 
The lifetime and scope
of these dynamic variables span the entire program, and they can be dynamically created and operated on
at any point in the program. Section~\ref{sec-var-dynamic} further discusses the concept of dynamic variables.
 
 \section {The DELAY and APPLY Operators}
 \label {sec-op-delay}
 
 POET provides two operators, $DELAY$ and $APPLY$,  to support the delay of 
 expression evaluation. Such delay is desired when incrementally constructing pattern expressions that contain 
 un-initialized variables (see Section~\ref {sec-pattern}).
 %These operations can be used to delay evaluation of an arbitrary
 %expression, whether the expression is 
% both in the local (e.g., inside the body of a xform routine) and global scopes.
 
 \label {sec-op-DELAY} 

The syntax of invoking the {\it DELAY} operator is
\begin {verbatim}
DELAY "{" <exp> "}"
\end {verbatim}
This operation saves the input expression, which could potentially be a sequence of POET statements and expressions, 
 in its original form and saves it for later evaluation.
The result is the internal  representation of the saved expression and 
can be stored into an arbitrary variable, e.g., passed as parameters to an xform routine invocation, to be evaluated later.
%The delayed operations are in a way similar to an {\it xform} routine declaration except they are defined and invoked using a different syntax (defined using the $DELAY$ operator and invoked using the {\it APPLY} operator), 
%they don't have parameters, and they can operate on global variables (when defined in the global scope) or local variables (when defined inside a $xform$ routine). 

%\subsection {The $APPLY$ operator}
\label {sec-op-APPLY}

The syntax of invoking the {\it APPLY} operator is
%\begin {verbatim}
{\it APPLY $<$exp$>$}, 
%\end {verbatim}
which triggers all delayed expressions contained in $<$exp$>$ to be evaluated and returns the evaluation result.
 
 \section {Operations On Tracing Handles}
\label {sec-op-trace}
POET supports a special kind of global variables called {\it tracing handles}, which can be embedded within the
internal representations of various computations to trace transformations to fragments of code. 
Once embedded inside a compound data structure, tracing handles 
become integral components of the data structure.
Transformations to the data structure therefore can be implemented by simply modifying the values of 
the embedded tracing handles. 
%Note that when inside a $xform$ function, trace handles
%can modified on through built-in transformation operations, such as REPLACE, 
%defined in Section~\ref{sec-op-xform}.
As various transformations are applied to the data structure, these tracing handles can be automatically replaced
with new values, thus making the ordering of different
transformations extremely flexible, and one can easily adjust
transformation orders as desired. 

The following POET operations can be used to set up and maintain tracing handles.

\subsection {TRACE (x, exp)}
Here $x$ is a single or a list of variables.
These variables become tracing handles during the evaluation of the
$exp$ expression, so that they may be used to trace transformations
performed by $exp$.
For example, in the following evaluation in POET/test/gemmATLAS/gemmKernel.pt,
\begin {verbatim}
TRACE (Arepl, ScalarRepl[... trace_vars=Arepl;.... ](...))
\end {verbatim}
the variable $Arepl$ is treated as a tracing handle during the invocation of the {\it xform}
routine $ScalarRepl$, so that the routine can modify $Arepl$ to contain the names of new variables created by the routine.

\subsection {INSERT (x, exp)}
\label {sec-op-insert}

This operation inserts tracing handle $x$, together with all the other tracing handles that are declared together 
with $x$ and following $x$ in the same declaration, 
to be embedded inside expression $exp$ if possible
so that $x$ may be used to trace transformations within $exp$. 
%For example, the operation {\it INSERT}$(gemm,gemm)$ (used in POET/test/gemmATLAS/gemm.pt)
%inserts all the trace handles declared together with  
%$gemm$ into the data structure contained in $gemm$, so that all the tracing handles become 
%embedded within the internal representation of the input code.
%In order for the tracing handles to be successfully inserted inside a computation, the handles 
%must have the correct values; that is, the values of the tracing handles must indeed be part of the input 
%expression  to the {\it INSERT} operation.
A special case of invoking the {\it INSERT} operation is {\it INSERT}$(tophandle, tophandle)$, where $tophandle$ is the first tracing handle that was followed by a collection of other handles 
declared together. Note for the {\it INSERT} operation to work, the tracing handles
 must have been declared in the same order as the order of encountering them in a pre-order traversal
 of the input computation.

\subsection {ERASE(x, exp)}
Here $x$ is a single or a list of tracing handles, and $exp$ is an arbitrary expression.
This operation %removes all the tracing handles in $x$ from the input code contained in $exp$; 
%that is, it 
returns a new computation that is equivalent to $exp$ but no longer 
contains any trace handles in $x$. 
For example, if $input = Stmt\#(x)$, where $x$ is a tracing handle and contains value $3$, then
%\begin {verbatim}
{\it ERASE(x,input)} returns {\it Stmt\#3}.
%\end {verbatim}
As a special case, the invocation {\it ERASE}$(x,x)$, returns the value contained in the variable
$x$ (i.e., the resulting value is no longer a tracing handle).
For example, if $x$ is a trace handle and $x = ``abc"$, then
%\begin {verbatim}
{\it ERASE(x)} returns "abc".
%\end {verbatim}

\subsection {COPY(exp) }
Instead of explicitly specifying which tracing handles to erase from an input expression $exp$,
the operation {\it COPY}$(exp)$ replicates $exp$ with a copy that has no tracing handles at all (i.e., all tracing handles are erased). 
For example, if $input = Assign\#(x, y)$, where both $x$ and $y$ are tracing handles with values $``var"$
and $4$ respectively, then
{\it COPY(input)} returns {\it Assign\#(``var", 4)}. 


\subsection {SAVE (v1,v2,...,vm)}
Here v1,v2, ..., vm is a tuple of tracing handle names. This operation saves the current value of each tracing handle so that the values of v1,v2,...,vm can be restored later. 
%After a sequence of transformations to these tracing handles are finished and the results output to an external file, the original values of v1,v2,...,vm  can be restored so that a new sequence of transformations can start afresh. 
%This operation therefore allows different transformations to be applied 
%independently to a single input code. 

\subsection {RESTORE (v1, v2, ..., vm)}
Here v1,v2, ..., vm is a tuple of tracing handle names. 
This operation restores the last value saved for each tracing handle.
The $SAVE$ and $RESTORE$ operations are usually used together for saving and restoring
information relevant to trace handles. Both the $SAVE$ and $RESTORE$ operations return
the empty string as result.

\section {Transformation Operations}
\label {sec-op-xform}
POET provides several built-in operations, including replication, permutation, and replacement of code fragments,  to 
 apply a wide variety of transformations to input computations. All built-in operations support the update of tracing handles embedded within their input computations; that is,
each tracing handle embedded within the input will be modified to contain the transformation result 
of its original value. 
Note that except for modifying tracing handles,  all built-in operations return their transformation results
without any other direct modifications to the input code. 

\subsection {DUPLICATE(c1,c2,input)}
Here $c1$ is a single expression, $c2$ is a list of expressions, and $input$ is the input computation to transform. This operation replicates $input$ with multiple copies, each copy replacing the code fragment $c1$ in $input$ by a different component in the list $c2$. It returns a list of the copies as result. 
For example,
\begin {verbatim}
   input = Stmt#"var";
   print ("DUPLICATE(\"var\", (1 2 3), input) = " DUPLICATE("var", (1 2 3), input));
\end {verbatim}
produces the following output.
\begin {verbatim}
DUPLICATE("var", (1 2 3), input) =  Stmt#1 Stmt#2 Stmt#3 NULL
\end {verbatim}

\subsection {PERMUTE(config,input)}
Here $input$ is a list of expressions, and $config$ is a list of integers that specify the index of permutation location for each component in $input$.
This operation reorders elements in the $input$ list based on $config$, which defines a position for each element in $input$.
For example,
\begin {verbatim}
PERMUTE((3 2 1), ("a" "b" "c")) returns ("c" "b" "a")
\end {verbatim}

\subsection {REBUILD(exp)} 
This operation takes a single POET expression $exp$ and returns the result of 
rebuilding $exp$. Here for each code template object contained in $exp$, 
the rebuilding process replaces the object in $exp$ by invoking the $rebuild$ attribute defined for the corresponding 
code template type (see Section~\ref {sec-code-attr}) if appropriate. The operation therefore can be used to
automatically eliminate redundancies (e.g., empty strings) in $exp$ based on customizable definitions for each 
relevant code template type.

\subsection {REPLACE(c1,c2,input)}
Here $input$ is the input computation to transform, $c1$ is an expression embedded inside $input$, 
and $c2$ is the new expression to replace $c1$, 
This operation replaces all occurrences of the code fragment $c1$ in $input$ with $c2$. 
For example, 
\begin {verbatim}
REPLACE("x","y",SPLIT("","x*x-2"))  returns  "y" "*" "y" "-" 2 NULL
\end {verbatim}

\subsection {REPLACE(config, input)}
Here $input$ is the input computation to transform, and $config$ is a list of pairs in the format
of $(orig, repl)$, where $orig$ is an expression embedded inside $input$, and $repl$ is the expression
to replace $orig$. This operation traverses the $input$ to locate the $orig$ component of each pair 
in $config$  and replaces each $orig$  with $repl$ in $input$.
Each $(orig,repl)$ pair in $config$ is expected to be processed exactly once,
in the order of their appearances in $config$,  during  a pre-order traversal of the $input$.
If there is any pair never processed in $config$, the rest of the specifications in $config$ will be 
ignored, and a warning is issued.
For example
\begin {verbatim}
REPLACE( (("a",1) ("b",2) ("c",3)), Bop#("+","a",Bop#("-","b","c"))) 
    =  Bop#("+",1,Bop#("-",2,3))
\end {verbatim}

\section {The Conditional Expression (The ``?:" operator)}
POET supports conditional evaluation of expressions using the following syntax (same as C).
\begin {verbatim}
<cond> ? <exp1> : <exp2>
\end {verbatim}
Here the $<$cond$>$ expression is first evaluated, which should return a boolean (integer value).
If the return value of $<$cond$>$ is true, the result of evaluating $<$exp1$>$ is returned; otherwise,
the result of evaluating $<$exp2$>$ is returned.

%%%%%%%%%%%%%%
\chapter {Statements}
\label {chap-stmt}

In POET, statements are considered special expressions whose results may be ignored when composed into a sequence. For example, when a collection of statements $s_1,s_2,...,s_m$ is
composed into a sequence, the evaluation results of the previous $s_1,s_2,...,s_{m-1}$ statements
are thrown away, and only the result of the last statement is returned. 
In contrast, when a collection of expressions $e_1,e_2,...,e_m$ is composed into a sequence,
the evaluation result is a list that contains the result of all expressions $e_1,e_2,...,e_m$ as components
(in POET, when expressions are simply listed together, they are considered operands in a list construction operation. See Section~\ref {sec-list}).

POET statements serve to provide  
control flow support such as sequencing of evaluation, 
conditional evaluation,  loops, and early returns from xform routines. 

\section {Single Statements}

\subsection {The Expression statement}
The syntax for the expression statement is
\begin {verbatim}
<exp> ;
\end {verbatim}
An expression statement is composed by following any POET expression with a semicolon (i.e., ``;").
If an expression is followed by a ``;", its evaluation result is always an empty string,
and the result is ignored when composed with other statements.
Expression statements are used to support sequencing of statements --- that is, only the result of
the last expression is returned, and the results of all previous evaluations are ignored.


\subsection {The RETURN (return) statement}
The syntax for the RETURN statement is
\begin {verbatim}
RETURN <exp> ;
\end {verbatim}
or
\begin {verbatim}
return <exp> ;
\end {verbatim}
The RETURN or return statement must be inside the body of a $xform$ routine (a runtime error is raised
otherwise). When evaluated, it exits the $xform$ routine with the result of evaluating $<$exp$>$. 
The RETURN (return) statement is provided to allow convenient
early returns from xform invocations.

\subsection {Statement Block}
\label {sec-stmt-block}
The syntax for a statement block is
\begin {verbatim}
{ stmt1  stmt2  ... stmtm }
\end {verbatim}
Here $stmt1,stmt2,...,stmtm$ are a sequence of statements. So a statement block merely combines a sequence of statements into a single one. The value of the statement block is the value of the last statement $stmtm$.

\section {Conditionals}
\subsection {The If-else Statement}

The syntax for the {\it if-else} statement is
\begin {verbatim}
if ( <cond> )  <stmt1>  [ else  <stmt2> ]
\end {verbatim}
Here $<$cond$>$ is a POET boolean expression, and $<$stmt1$>$ and $<$stmt2$>$ are 
single statements (including statement blocks). 
If $<$cond$>$ evaluates to $true$ (a non-zero integer), $<$stmt1$>$
is evaluated, and the value of the last expression in $<$stmt1$>$ is returned; 
otherwise, $<$stmt2$>$ is evaluated, and the value of the last expression in $<$stmt2$>$ is returned. 
If $<$cond$>$ evaluates to $false$ and the $else$ branch is missing, then an empty string is returned as result of evaluation. 

\subsection {The Switch Statement}

The syntax for the {\it switch} statement is
\begin {verbatim}
switch (<cond>) 
{
case <pattern1> : <stmts1>
case <pattern2> : <stmts2>
......
case <patternm> : <stmtsm>
[ default :  <default_stmts> ]
}
\end {verbatim}
Here $<$cond$>$ is an arbitrary expression, $<$pattern1$>$,$<$pattern2$>$,..., $<$patternm$>$
are pattern specifiers as defined in Section~\ref {sec-pattern}, and $<$stmts1$>$,$<$stmts2$>$,...,$<$stmtsm$>$ and $<$default\_stmts$>$ are sequences of statements or expressions. 
The switch statement first evaluates $<$cond$>$ and then matches the result of $<$cond$>$ against
each pattern specifier in order. Specifically, if $<$cond$>$ : $<$pattern1$>$ succeeds, then $<$stmts1$>$ is evaluated and the result of $<$stmts1$>$ becomes the result of the switch statement; otherwise, the result of $<$cond$>$ is matched against $<$pattern2$>$, and so forth. If none of the
patterns can successfully match the value of $<$cond$>$, the $<$default\_stmts$>$ is evaluated and returned as result. If no pattern matching succeeds and no default statements are specified (the default branch is optional), an error message is issued.

Note that when evaluating the switch statement, only one pattern will 
be successfully matched with the given $<$cond$>$ throughout the evaluation. 
Once a pattern matching succeeds, 
the corresponding statements are evaluated and the result is returned immediately (no statements in the following patterns will be evaluated). If two patterns need to be combined,
they should be combined into a single pattern specification using the $|$ operator, shown in Section~\ref {sec-pattern}.

The $switch$ statement syntax is equivalent to the following syntax using if-else statements.
\begin {verbatim}
var = <cond>;
if (var : <pattern1>)  { <stmts1> }
else if (var : <pattern2>) { <stmts2> }
......
else if (var : <patternm>) { stmtsm> }
[else { <default_stmts> } ]
\end {verbatim}

\section {Loops}
\subsection {The {\it for} Loop}
The syntax of the $for$ loop is as the following.
\begin {verbatim}
for ( <init> ; <cond> ; <incr>)  
     <body>
\end {verbatim}
Here $<$init$>$ and $<$incr$>$ are arbitrary expressions, $<$cond$>$ is a boolean expression, and $<$body$>$ is a single statement (could be a statement block) that comprises the loop body.
%The $for$ loop has the same syntax and semantics as the {\it for} loop in the C language.
First, the $<$init$>$ expression is evaluated to initialize the loop. Then, $<$cond$>$ is evaluated.
If $<$cond$>$ returns TRUE, $<$body$>$ and $<$incr$>$ are evaluated, and $<$cond$>$ 
is evaluated again to determine whether to repeat the evaluation of $<$body$>$ and $<$incr$>$.

As example, the following loop prints out each element contained within a list $input$.
\begin {verbatim}
for (p_input = input; p_input != NULL; p_input = TAIL(p_input)) {
    print ("seeing element: " HEAD(p_input));
}
\end {verbatim}

\subsection {The  {\it foreach} Loop}
\label {sec-stmt-foreach}
The syntax of the $foreach$ loop is
\begin {verbatim}
foreach <pattern> \in <exp> s.t. <succ> do
    <body>
enddo
\end {verbatim}
or the older syntax
\begin {verbatim}
foreach (<exp> : <pattern> : <succ> )
    <body>
\end {verbatim}

Here $<$exp$>$ is the an arbitrary expression, $<$pattern$>$ is a pattern specifier as defined in Section~\ref {sec-pattern},  $<$succ$>$ is a boolean expression, and $<$body$>$ is a single statement (or a statement block). The $foreach$ statement traverses the input computation $<$exp$>$ 
and matches each component contained in $<$exp$>$ against the pattern specifier $<$pattern$>$.
If any pattern matching succeeds for a code fragment $sub\-exp$ in $<$exp$>$ and if $<$succ$>$ evaluates to true, it evaluates the $<$body$>$ statement. If $<$succ$>$ is set to be the boolean constant value FALSE, the foreach loop will continue traversing the $sub\-exp$ in order to find additional matches. 
The foreach statement therefore serves as the built-in operation for collectively applying  pattern matching analysis to an input computation. 

Note that in order to process each fragment that matches a given pattern, the $<$pattern$>$ specifier needs to contain local variables that are assigned with the matched fragment
when the matching succeeds. The following example illustrates how to print out all the loop controls inside an $input$ computation.
\begin {verbatim}
foreach curLoop = Loop \in input do 
  print ("found a loop: " curLoop);
enddo
\end {verbatim}
The above is equivalent to
\begin {verbatim}
foreach (input : (curLoop = Loop) : TRUE) 
{
  print ("found a loop: " curLoop);
}
\end {verbatim}

The expression $curLoop=Loop$ is enclosed inside a pair of 
parentheses in the first syntax because the assignment operator has lower precedence than the $:$
operator.
The following loop collects all the loop nests within an $input$ computation. 
\begin {verbatim}
loopNests = "";
foreach curNest = Nest \in s.t. FALSE do
   loopNests = BuildList(curNest, loopNests);
enddo
\end {verbatim}
Here because loop nests may be inside one another, the $<$succ$>$ parameter of the foreach loop is set to {\it FALSE} so that the pattern matching can continue inside already located loop nests. 


Since each foreach loop makes a traversal over the entire input,
it is recommended to use the foreach loop to collect information only. If the input computation needs to be transformed, it is better to invoke a {\it REPLACE} operation (see Section~\ref {sec-op-xform}) after a foreach loop has finished, as the transformation operations may disrupt the traversal by the {\it foreach} loop.

To traverse an input in reverse order, use the following 
\begin {verbatim}
foreach <pattern> \in reverse(<exp>) s.t. <succ> do
    <body>
enddo
\end {verbatim}
or the older syntax using like the following. 
\begin {verbatim}
foreach_r (<exp> : <pattern> : <succ> )
    <body>
\end {verbatim}
The above essentially has the same syntax and semantics as the {\it foreach} loop, except that
it traverses the input $<$exp$>$ in the reverse order of the traversal by the corresponding {\it foreach} loop.
The different traversal order allows the relevant information to be gathered and saved with more flexibility.
For example, the following code
\begin {verbatim}
loopNests = NULL;
foreach curNest = Nest \in  reverse(input)  s.t. FALSE do
   loopNests = curNest :: loopNests;
enddo
\end {verbatim}
or in older syntax
\begin {verbatim}
loopNests = NULL;
foreach_r (input : (curNest = Nest) : FALSE) 
   loopNests = curNest :: loopNests;
\end {verbatim}
collects all the loop nests inside $input$ and saves the loop nests in a list in the same order of their 
appearances in the original code. In contrast, the almost identical loop in Section~\ref {sec-stmt-foreach}
saves all the loop nests in the reverse order of their appearances in $input$.

\subsection {The BREAK (break) and CONTINUE (continue) statements}
Just like the $break$ and $continue$ statements in the C language, POET provides $break$ and $continue$ statements to jump to the continuation and exit of a loop. The syntax for both statements are
\begin {verbatim}
BREAK  
CONTINUE
\end {verbatim}
or
\begin {verbatim}
break
continue
\end {verbatim}
These two statements have the same meaning as those in C, and can be used to break out of (or back to the start) of {\it for, foreach}, and {\it foreach\_r} loops.


\newpage
\addcontentsline{toc}{section}{Append A. Context-free grammar of the POET language}
\appendix 
\begin {center}
{\bf \Large Appendix A.  Context-free grammar of the POET language}
\end {center}
\begin {verbatim}
poet :  commands ; 
commands :  commands command | ;

command :  "<" "parameter" ID  paramAttrs "/>"
    | "<" "define" ID exp "/>"
    | "<" "eval" exp "/>"
    | "<" "cond" exp "/>"
    | "<" "trace" traceVars "/>"
    | "<" "input" inputAttrs inputRHS
    | "<" "output" outputAttrs "/>"
    | "<" "code" ID codeAttrs codeRHS
    | "<" "xform" ID xformAttrs xformRHS

paramAttrs :  paramAttrs paramAttr | ;
paramAttr : "type" "=" typeSpec  | "default" "=" expUnit
    |  "parse" "=" parseSpec  |  "message" "=" STRING
traceVars : ID |  traceVars "," traceVars
inputAttrs : inputAttr inputAttrs  | ;
inputAttr : "debug" "=" expUnit  |  "annot" "=" expUnit  |  "cond" "=" expUnit
    |  "syntax" "=" expUnit  |  "parse" "=" "POET"  |  "parse" "=" parseSpec
    |  "from" "=" expUnit   |  "to" "=" ID  |  "to" "=" "POET"
inputRHS : ">" inputCodeList "</input>"  |  "/>"
inputCodeList : inputCode | inputCode inputCodeList

outputAttrs : outputAttr outputAttrs  | ;
outputAttr :   "cond" "=" expUnit  |   "syntax" "=" expUnit 
    |   "from" "=" expUnit   |  "to" "="  expUnit
codeAttrs :  codeAttrs codeAttr | ;
codeAttr : "pars" "=" "(" codePars ")"  | ID "=" typeSpec
    | "cond" "=" expUnit  | "rebuild" "=" expUnit
    | "parse" "=" parseSpec  | "output" "=" typeSpec
    | "lookahead" "=" INT  |  "match" "=" typeSpec
codeRHS : ">" exp "</code>   |   "/>"
xformAttrs : xformAttrs xformAttr  |   ;
xformAttr: "pars" "=" "(" xformPars ")" | "output" "=" "(" xformPars ")"
    |  ID "=" typeSpec  
xformRHS : ">" exp "</xform>"  |  "/>"
codePars :  ID  | ID ":" parseSpec  | codePars "," codePars 
xformPars : ID | ID ":" typeSpec | xformPars "," xformPars

typeSpec :  INT  |  STRING  |  "_" |  ID
    | "INT" | "STRING"  | "ID"  |  "VAR" | "CODE"  |  "XFORM"  |  "TUPLE" 
    | "MAP" "(" typeSpec "," typeSpec ")" |  "EXP" 
    | typeSpec "..." | typeSpec "...." 
    | typeSpec ".." typeSpec  | ID "#" typeSpec  
    | "(" typeList ")"  |  "(" typeTuple ")"  
    | typeSpec "|" typeSpec | "~" typeSpec
    | typeSpec "+" typeSpec | typeSpec "-" typeSpec | typeSpec "*" typeSpec
    | typeSpec "/" typeSpec | typeSpec "%" typeSpec | typeSpec "::" typeSpec
typeList :  typeSpec  |  typeSpec typeList
typeTuple :  typeSpec "," typeSpec  |  typeTuple "," typeSpec

patternSpec : typeSpec | "CLEAR" ID
     | "(" patternSpecList ")" | "(" patternSpecTuple" ")"  |  patternSpec "|" patternSpec
     |  ID "[" xformConfig "]"  | ID "#" patternSpec | ID "=" patternSpec               
patternSpecList :  patternSpec patternSpec | patternSpec patternSpecList
patternSpecTuple :  patternSpec "," patternSpec | patternSpecTuple "," patternSpecTuple

parseSpec : typeSpec 
    | "TUPLE" "(" parseSpecList ")"  | "LIST" "("  parseSpec ","  singleType ")"
    | "(" parseSpecList ")" | "(" parseSpecTuple" ")"  |  parseSpec "|" parseSpec
    |  ID "[" xformConfig "]"  | ID "#" parseSpec
    | ID "=" parseSpec               
parseSpecList :  parseSpec parseSpec | parseSpec parseSpecList
parseSpecTuple :  parseSpec "," parseSpec | parseSpecTuple "," parseSpecTuple
xformConfig : ID "=" parseSpec  | xformConfig ";" xformConfig

exp : expUnit | exp exp | exp "::" exp | exp ","  exp
    | "car" expUnit | "cdr" expUnit | "HEAD" expUnit | "TAIL" expUnit | "LEN" expUnit
    | "ERROR" expUnit  |  "PRINT" expUnit | "print" expUnit 
    |  DEBUG "[" INT "]" "{" exp "}"  |  DEBUG "{" exp "}"
    | exp "=" exp  | exp "+=" exp | exp "-=" exp 
    | exp "*=" exp | exp "/=" exp | exp "%=" exp
    | exp "=>" parseSpec | exp "==>" parseSpec
    | exp "?" exp ":" exp
    | exp "&&" exp | exp "||" exp | "!" exp  | exp "|" exp
    | exp "<" exp | exp "<=" exp | exp "==" exp
    | exp ">" exp | exp ">=" exp | exp "!=" exp
    | exp ":" patternSpec | "-" exp
    | exp "+" exp | exp "-" exp | exp "*" exp | exp "/" exp | exp "%" exp
    | exp "^" exp     | "SPLIT" "(" exp "," exp ")"
    | "REPLACE" "(" exp "," exp ")" | "REPLACE "(" exp "," exp "," exp ")"
    | "PERMUTE" "(" exp "," exp ")"  | "DUPLICATE" "(" exp "," exp "," exp ")"  
    | "COPY" expUnit  |  "REBUILD" expUnit
    | "ERASE" "(" exp "," exp ")" | INSERT "(" exp "," exp ")"
    | "DELAY" "{" exp "}"  |  "APPLY" expUnit  | "CLEAR" expUnit  
    | "SAVE" expUnit  |  "RESTORE"  expUnit  | "TRACE" "(" exp "," exp ")"
    | expUnit "..." | expUnit "...." | expUnit ".." expUnit 
    | "MAP" "(" typeSpec "," typeSpec ")"
    | exp "[" exp "]"  |  exp "#" expUnit
    | stmt

stmt:  exp ";" | "{" exp "}"  |  "RETURN" expUnit | "return" expUnit
    | "if" "(" exp ")" stmt  |  "if" "(" exp ")" stmt "else" stmt
    | "switch" "(" exp ")" "{" cases "}"
    | "for" "(" exp ";" exp ";" exp ")" stmt
    | "foreach" id = patternSpec \in exp "s.t." exp do stmt enddo
    | "foreach" id = patternSpec \in reverse(exp) "s.t." exp do stmt enddo
    | "foreach" "(" exp ":" patternSpec ":" exp ")" stmt
    | "foreach_r" "(" exp ":" patternSpec ":" exp ")" stmt
    | "CONTINUE" | "continue" |  "BREAK"  | "break" 

expUnit: "(" exp ")" | ID | "XFORM" | "CODE" | "TUPLE" | "STRING" | "INT" | "VAR"
    | INT | STRING | "_"

cases : cases "case" patternSpec ":" exp
    |  cases "default" ":" exp
    | "case" patternSpec ":" exp

\end {verbatim}
\printindex


\bibliographystyle{abbrv}
\bibliography{POET}
\end{document}

