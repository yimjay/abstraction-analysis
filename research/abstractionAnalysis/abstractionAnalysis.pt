include ExpStmt.incl
include analysis.pi

<parameter inputFile default="" message="input file name"/>
<parameter inputLang default="C++front.code" message="file name for input language syntax" />
<parameter specFile default="" message="abstraction specification file"/>

<parameter outputFile default=""  message="output file name"/>

<input from=(inputFile) syntax=(inputLang) to=inputCode/>
<input from=(specFile) syntax=("AbstractionSpecification.code") to=spec/>

<code Abstraction pars=(name, data, methods) />
<code ClassType pars=(name, body, parents)/>

<eval 
   result = NULL;
   foreach class : CODE.ClassType \in inputCode do
   foreach abs : CODE.Abstraction \in spec do
      result1  = XFORM.MatchAbstraction(inputCode, abs);
      if (result1 != NULL) {
         result = result1 :: result;
      }
   enddo
   enddo
   result
/> 

<output to=(outputFile) syntax="abstraction_output.code" from=res/>

<xform MemberVariablesOfClass pars=(body)/>
<xform PublicMethodsOfClass pars=(body)/>

<*** f_v maps all variables in data_a  to its corresponding C++ member variables;
     f_d maps each possible abstraction state in data_a to its corresponding C++ data representation *>
<code AbstractionDataImpl pars=(data_a, f_v, f_d)/>

<*** f_i maps each state transition in methods_a to its corresponding C++ code implementation***>
<code AbstractionFunctionImpl pars=(methods_a, f_i)/>

<*** f_v maps all variables in abs  to its corresponding C++ member variable implementation;
     f_d maps each possible abstraction state in abs to its corresponding C++ data representation
     f_m maps ach state transition in methods_a to its corresponding C++ code implementation***>
<code AbstractionImpl pars=(abs, f_v, f_d, f_m)/>

<*** returns AbstractionDataImpl if semantics of data_a can be successfully mapped 
to the variables and methods of the C++ class **>
<xform MatchDataSemantics(data_a, vars_i, methods_i)/>

<********************
input = (name_i, vars_i, methods_i) : the name, member variables, and member methods of C++ class to analyze
abs = (name_a, vars_a, data_a, methods_a) : the name, variables, data, and interface functions of abstraction specification to match against
return: (f_v, f_d, f_m)  where  f_v maps var_a to vars_i, and f_m  maps methods_a to C++ code that invokes methods_i.
***********************>
<xform  MatchAbstraction pars=(input, abs) >
  CODE.ClassType#(name_i, body_i) = input;
  vars_i = XFORM.MemberVariablesOfClass(body_i); methods_i = XFORM.PublicMethodsOfClass(body_i);
  CODE.Abstraction#(name_a, vars_a, data_a, methods_a) = abs;

  result = NULL;
  foreach AbstractionDataImpl#(_, f_v =_, f_d = _) in MatchDataSemantics(data_a, vars_i, methods_i) do
     f_m = NULL;
     succ = TRUE;
     foreach m_a  = CODE.MethodSpec \in methods_a do
       c_m = MatchFunctionSemantics(m_a, methods_i, f_v, f_d);
       if (c_m : NULL) {
          succ = false; break;
       } 
       f_m =  XFORM.AdaptApI(m_a, c_m) :: f_m;
     enddo
     if succ then
       result = CODE.AbstractionImpl#(abs, f_v, f_d, f_m)  :: result;
     endif;
   enddo;
   return result;
</xform>


