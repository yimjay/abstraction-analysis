include ExpStmt.incl
include analysis.pi

<************************************************************
Define input command line parameters
*************************************************************>
<parameter inputFile default="" message="input file name"/>
<parameter inputLang default="C++front.code" message="file name for input language syntax" />
<parameter specFile default="" message="abstraction specification file"/>

<************************************************************
Define output command line parameters
*************************************************************>
<parameter outputFile default=""  message="output file name"/>

<************************************************************
Parse inputFile and specFile
*************************************************************>
<input from=(inputFile) syntax=(inputLang) to=inputCode/>
<input from=(specFile) syntax=("AbstractionSpecification.code") to=spec/>

<************************************************************
Main driver for abstraction analysis
*************************************************************>
<eval 
  result = NULL;
  foreach class = CODE.ClassType \in inputCode do
    foreach abs = CODE.Abstraction \in spec do
      <*print("Arguments for MatchAbstraction are: ");
      print("class: " class);
      print("abs: " abs);*>
      result1  = XFORM.MatchAbstraction(class, abs);
      if (result1 != NULL) {
         result = result1 :: result;
      }
    enddo
  enddo
  result
/>

<************************************************************
Unparse results
*************************************************************>
<*<output to=(outputFile) syntax="abstraction_output.code" from=result/>*>

<************************************************************
Forward declarations
************************************************************>

<*** f_v maps all variables in data_a to its corresponding C++ member variables;
     f_d maps each possible abstraction state in data_a to its corresponding C++ data representation *>
<code AbstractionDataImpl pars=(data_a, f_v, f_d)/>

<*** f_i maps each state transition in methods_a to its corresponding C++ code implementation***>
<code AbstractionFunctionImpl pars=(methods_a, f_i)/>

<*** f_v maps all variables in abs  to its corresponding C++ member variable implementation;
     f_d maps each possible abstraction state in abs to its corresponding C++ data representation
     f_m maps each state transition in methods_a to its corresponding C++ code implementation***>
<code AbstractionImpl pars=(abs, f_v, f_d, f_m)/>

<code ZeroOrMoreElements parse=("elem"|"...")/>

<*** returns AbstractionDataImpl if semantics of data_a can be successfully mapped 
to the variables and methods of the C++ class ***>
<xform MatchDataSemantics pars=(data_a, vars_i, methods_i)/>

<*** returns AbstractionFunctionImpl if semantics of m_a can be successfully mapped 
to the variables and methods of the C++ class ***>
<xform MatchFunctionSemantics pars=(m_a, methods_i, f_v, f_d)/>

<xform PossibleMappings pars=(p_v, p_i)/>
<xform PositionVariablesOfAbstraction pars=(data_a)/>
<xform PointerMemberVariablesOfClass pars=(vars_i)/>
<xform TranslateToImplementation pars=(d_a, f_v)/>
<xform AbstractionTransition pars=(m_a)/>
<xform AdaptApI/> <*todo: needs design; using placeholder*>
<xform SymbolicEvaluation pars=(m_i, f_d)/>



<************************************************************
Define MatchAbstraction
*************************************************************
note: arguments
input = (name_i, vars_i, methods_i) 
      : the name, member variables, 
      and member methods of C++ class to analyze
abs = (name_a, vars_a, data_a, methods_a) 
      : the name, variables, data, 
      and interface functions of abstraction specification 
      to match against
note: returns
(f_v, f_d, f_m)  where  
      f_v maps var_a to vars_i, 
      f_m  maps methods_a to C++ code that invokes methods_i.
*************************************************************>
<xform MatchAbstraction pars=(input, abs)>
  CODE.ClassType#(name_i, body_i, _) = input;

  vars_i = XFORM.member_variables(body_i);
  print("******************************member variables are " vars_i);

  methods_i = XFORM.member_functions(input);
  print("******************************member functions are " methods_i);

  CODE.Abstraction#(name_a, data_a, methods_a) = abs;

  result = NULL;
  foreach AbstractionDataImpl#(_, f_v =_, f_d = _) \in MatchDataSemantics(data_a, vars_i, methods_i) do
  <**
    f_m = NULL;
    succ = TRUE;
    foreach m_a  = CODE.MethodSpec \in methods_a do
      c_m = MatchFunctionSemantics(m_a, methods_i, f_v, f_d);
      if (c_m : NULL) {
        succ = false; 
        break;
      } 
      f_m : (XFORM.AdaptApI(m_a, c_m)) :: f_m;
    enddo
    if (succ) then
      result : CODE.AbstractionImpl#(abs, f_v, f_d, f_m)  :: result;
    endif;
  **>
  print("****************************** call to MatchDataSemantics");
  enddo;
  return result;
  
</xform>

<************************************************************
MatchDataSemantics
*************************************************************
note: data_a: vars from abstraction
      vars_i: vars from implementation
      methods_i: methods from implementation
note: returns AbstractionDataImpl#(f_v, f_d)
*************************************************************>
<xform MatchDataSemantics pars=(data_a, vars_i, methods_i)>
  print("******************************Calling MatchDataSemantics");
  print("data_a is " data_a);
  print("vars_i is " vars_i);
  print("methods_i is " methods_i);

  p_v = XFORM.PositionVariablesOfAbstraction(data_a);
  print ("Position variables:" p_v);
  
  p_i = XFORM.PointerMemberVariablesOfClass(vars_i);
  print ("Pointer variables:" p_i);
  
  result = NULL;

  foreach f_v \in XFORM.PossibleMappings(p_v, p_i) do
    DEBUG{f_v};
    D_i = NULL;  <<* D_i is all internal state implementations
    foreach d_a = ID \in data_a do
      <**attention: currently manually checks d_a is not elem ...**>
      <*if (!(d_a : "elem"|"...")) {*>
      if (!(d_a : CODE.ZeroOrMoreElements)) {
        d_i = XFORM.TranslateToImplementation(d_a, f_v);
        D_i = D_i :: d_i;
      }
    enddo;

    <*todo: get f_d: map state to data representation*>


    succ = TRUE;
    <**
    foreach m_i \in methods_i do
      d_j = XFORM.SymbolicEvaluation(m_i, f_d);
      if (!XFORM.is_subset(d_j, D_i))
        succ = FALSE;
        break;
    enddo;
  
    if (succ)
      result : CODE.AbstractionDataImpl#(f_v, f_d) :: result;
  **>
  enddo;  
  return result;

  
</xform>


<************************************************************
MatchFunctionSemantics
*************************************************************
note: arguments
m_a = 
methods_i = 
f_v = 
f_d = 
note: returns
*************************************************************>
<xform MatchFunctionSemantics pars=(m_a, methods_i, f_v, f_d)>
  <**
  result = NULL;

  foreach m_i = CODE.ClassTypeName \in methods_i do
    d_j = XFORM.SymbolicEvaluation(m_i, f_d);
    (d_a, d_b) = XFORM.AbstractionTransition(m_a);
    if (XFORM.is_subset((XFORM.TranslateToImplementation(d_a, f_v), D_i)) && (XFORM.is_subset((XFORM.TranslateToImplementation(d_b, f_v), d_j))))
      result : result :: (m_i, d_j);
  enddo;
  return result;
  **>
  print("******************************Calling MatchFunctionSemantics");
</xform>

<************************************************************
Helper Functions
*************************************************************>
<xform PositionVariablesOfAbstraction pars=(data_a)>
  print("******************************Calling PositionVariables");
  result=NULL;
  foreach n = ID \in DEBUG{data_a} do 
    <*if (!(n : "elem"|"...")) {*>
    if (!(n : CODE.ZeroOrMoreElements)) {
      print("n is " n);
      result = n :: result;
    }
  enddo;
 return result;
</xform>

<xform PointerMemberVariablesOfClass pars=(vars_i)>
  print("******************************Calling PointerMemberVariablesOfClass");
  result=NULL;
  foreach decl = CODE.TypeInfo#(t=_,v=_, _) \in DEBUG{vars_i} do
    if (t : CODE.PtrType) {
      result = decl :: result;
    }
  enddo;
  return result;
</xform>

<xform TranslateToImplementation pars=(d_a, f_v)>
  print("******************************Calling TranslateToImplementation");
  DEBUG{d_a};
  DEBUG{f_v};
  <*replace abstracted d_a by implemented f_v*>
  <*top elem -> head elem*>
</xform>

<xform AbstractionTransition pars=(m_a)>
  print("******************************Calling AbstractionTransition");
  DEBUG{m_a};
</xform>

<xform AdaptApI pars=(a, b)>
  print("******************************Calling Adapt");
</xform>

<xform PossibleMappings pars=(p_v, p_i)>
  print("******************************Calling PossibleMappings");
  result = NULL;
  foreach pv = ID \in p_v do
    foreach i = CODE.TypeInfo#(t=_,v=_, _) \in p_i do
      result = (pv, v) :: result;
    enddo;
  enddo;
  return result;
</xform>

<xform SymbolicEvaluation pars=(m_i, f_d)>
  print("******************************Calling SymbolicEvaluation");
  DEBUG{m_i};
  DEBUG{f_d};
</xform>
