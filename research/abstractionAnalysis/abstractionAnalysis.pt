include ExpStmt.incl
include analysis.pi

<************************************************************
Define input command line parameters
*************************************************************>
<parameter inputFile default="" message="input file name"/>
<parameter inputLang default="C++front.code" message="file name for input language syntax" />
<parameter specFile default="" message="abstraction specification file"/>

<************************************************************
Define output command line parameters
*************************************************************>
<parameter outputFile default="" message="output file name"/>

<************************************************************
Parse inputFile and specFile
*************************************************************>
<input from=(inputFile) syntax=(inputLang) to=inputCode/>
<input from=(specFile) syntax=("AbstractionSpecification.code") to=spec/>

<************************************************************
Main driver for abstraction analysis
*************************************************************>
<eval 
  result = NULL;
  n = 0;
  foreach class = CODE.ClassType \in inputCode do
    foreach abs = CODE.Abstraction \in spec do
      n += 1;
      print("*****************************************************************");
      print("CALL TO MAIN DRIVER OF PROGRAM #" n);
      print("*****************************************************************");
      <*print("Arguments for MatchAbstraction are: ");
      print("class:");
      print(class);
      print("abs:");
      print(abs);*>
      result1 = XFORM.MatchAbstraction(class, abs);
      if (result1 != NULL) {
         result = result1 :: result;
      }
    enddo;
  enddo;
  result;
/>

<************************************************************
Unparse results
*************************************************************>
<*<output to=(outputFile) syntax="abstraction_output.code" from=result/>*>

<************************************************************
Forward declarations
************************************************************>
<*** 
    data_a data from abstraction specification to match against
    f_v maps all variables in data_a to its corresponding C++ member variables;
    f_d maps each possible abstraction state in data_a to its corresponding C++ data representation 
***>
<code AbstractionDataImpl pars=(data_a, f_v, f_d)/>

<*** 
    methods_a list of state transitions of abstraction
    f_i maps each state transition in methods_a to its corresponding C++ code implementation
***>
<code AbstractionFunctionImpl pars=(methods_a, f_i)/>

<*** 
    abs the name, variables, data, 
        and interface functions of abstraction specification 
        to match against
    f_v maps all variables in abs  to its corresponding C++ member variable implementation;
    f_d maps each possible abstraction state in abs to its corresponding C++ data representation
    f_m maps each state transition in methods_a to its corresponding C++ code implementation
***>
<code AbstractionImpl pars=(abs, f_v, f_d, f_m)/>

<*** 
    Input: data_a data from abstraction specification to match against
           vars_i member variables of C++ class to analyze
           methods_i member methods of C++ class to analyze
    returns AbstractionDataImpl if semantics of data_a can be successfully mapped to the variables and methods of the C++ class
***>
<xform MatchDataSemantics pars=(data_a, vars_i, methods_i)/>

<*** 
    returns AbstractionFunctionImpl if semantics of m_a can be successfully mapped to the variables and methods of the C++ class
***>
<xform MatchFunctionSemantics pars=(m_a, methods_i, f_v, f_d)/>

<*** 
    Input: p_v = position variables of abstraction to be matched against
           p_i = pointer member variables of C++ class to be analyzed
    returns a list of possible implementations of all position variables of abstraction 
***>
<xform PossibleMappings pars=(p_v, p_i)/>

<*** 
    returns position variables of abstraction given set of valid internal states of abstraction
***>
<xform PositionVariablesOfAbstraction pars=(data_a)/>

<*** 
    returns pointer member variables of C++ class
***>
<xform PointerMemberVariablesOfClass pars=(vars_i)/>

<*** 
    Input = d_a : an abstraction state that includes list of abstraction variables (e.g., top)
            f_v : mapping of abstraction variables to class variables 
   returns implementation of abstraction state by replacing abstraction var by class variables
***>
<xform TranslateToImplementation pars=(d_a, f_v)/>

<*** 
    Given an abstraction state transition, returns starting and ending states
***>
<xform AbstractionTransition pars=(m_a)/>

<*** todo: needs design ***>
<xform AdaptApI/>

<*** todo: needs redesign ***>
<xform SymbolicEvaluation pars=(m_i, f_d)/>

<************************************************************
Define MatchAbstraction
*************************************************************
input = (name_i, vars_i, methods_i) 
      : the name, member variables, 
      and member methods of C++ class to analyze
abs = (name_a, vars_a, data_a, methods_a) 
      : the name, variables, data, 
      and interface functions of abstraction specification 
      to match against
returns (f_v, f_d, f_m)  where  
      f_v maps all variables in abs  to its corresponding C++ member variable implementation;
      f_d maps each possible abstraction state in abs to its corresponding C++ data representation
      f_m maps each state transition in methods_a to its corresponding C++ code implementation
*************************************************************>
<xform MatchAbstraction pars=(input, abs)>
  print("*****************************************************************");
  print("CALL TO MatchAbstraction");
  print("*****************************************************************");
  
  CODE.ClassType#(name_i, body_i, _) = input;

  vars_i = XFORM.member_variables(body_i);
  print("*****************************************************************Member variables are " vars_i);

  methods_i = XFORM.member_functions(input);
  <*print("*****************************************************************Member functions are " methods_i);*>

  CODE.Abstraction#(name_a, data_a, methods_a) = abs;

  result = NULL;
  foreach AbstractionDataImpl#(_, f_v =_, f_d = _) \in MatchDataSemantics(data_a, vars_i, methods_i) do
    print("f_v is " f_v);
    print("f_d is " f_d);
    f_m = NULL;
    succ = TRUE;

    foreach m_a = CODE.AbstractionMethod \in methods_a do
      <*print("m_a in MatchAbstraction is " m_a);*>
      c_m = MatchFunctionSemantics(m_a, methods_i, f_v, f_d);
      if (c_m : NULL) {
        succ = FALSE; 
        break;
      } 
      f_m = (XFORM.AdaptApI(m_a, c_m)) :: f_m;
    enddo;
    
    if (succ) {
      result = (CODE.AbstractionImpl#(abs, f_v, f_d, f_m))  :: result;
    }
  enddo;
  print("TEST OUTPUT in MatchAbstraction");
  return result;
  
</xform>

<************************************************************
MatchDataSemantics
*************************************************************
note: data_a: data from abstraction specification to match against
      vars_i: vars from C++ implementation to analyze
      methods_i: methods from C++ implementation to analyze
returns AbstractionDataImpl if semantics of data_a can be successfully mapped to the variables and methods of the C++ class
*************************************************************>
<xform MatchDataSemantics pars=(data_a, vars_i, methods_i)>
  print("******************************Calling MatchDataSemantics");
  <*print("data_a is " data_a);
  print("vars_i is " vars_i);
  print("methods_i is " methods_i);*>

  p_v = XFORM.PositionVariablesOfAbstraction(data_a);
  p_i = XFORM.PointerMemberVariablesOfClass(vars_i);
  
  result = NULL;

  foreach f_v=(_,_) \in XFORM.PossibleMappings(p_v, p_i) do
    print("f_v from Possible Mappings is " f_v);
    D_i = NULL;  <<* D_i is all internal state implementations

    print("data_a in MatchDataSemantics is " data_a);

    foreach d_a = CODE.Record#(var=_) \in data_a do
      print("d_a in MatchDataSemantics is " d_a);
      
      d_i = XFORM.TranslateToImplementation(d_a, f_v);
      print("d_i after call to TranslateToImplementation is " d_i);
      D_i = d_i :: D_i;
      
      <*if (!(d_a : CODE.ZeroOrMoreData)) {
        d_i = XFORM.TranslateToImplementation(d_a, f_v);
        print("d_i after call to TranslateToImplementation is " d_i);
        D_i = d_i :: D_i;
      }*>
      print("d_i is " d_i);
      print("D_i is " D_i);
    enddo;

    succ = TRUE;
    
    foreach m_i = CODE.FunctionDecl \in methods_i do
      print("Calling SymbolicEvaluation within MatchDataSemantics with m_i " m_i);
      D_j = XFORM.SymbolicEvaluation(m_i, D_i);
      if (!XFORM.is_subset(D_j, D_i))
        succ = FALSE;
        break;
    enddo;
  
    if (succ)
      result = (CODE.AbstractionDataImpl#(_,f_v,D_i)) :: result;
  
  enddo;  
  return result;
</xform>


<************************************************************
MatchFunctionSemantics
*************************************************************
m_a = single interface function of abstraction specification 
      to match against
methods_i = member methods of C++ class to analyze
f_v = maps all variables in abstraction to its corresponding C++ member variable implementation
f_d = maps each possible abstraction state in abs to its corresponding C++ data representation
returns AbstractionFunctionImpl if semantics of m_a can be successfully mapped to the variables and methods of the C++ class
*************************************************************>
<xform MatchFunctionSemantics pars=(m_a, methods_i, f_v, f_d)>
  print("******************************Calling MatchFunctionSemantics");
  <*print("m_a in MatchFunctionSemantics is " m_a);
  DEBUG{methods_i};
  DEBUG{f_v};
  DEBUG{f_d};*>

  result = NULL;

  foreach m_i \in methods_i do
    d_j = XFORM.SymbolicEvaluation(m_i, f_d);
    (d_a, d_b) = XFORM.AbstractionTransition(m_a);
    da_fv = XFORM.TranslateToImplementation(d_a, f_v);
    db_fv = XFORM.TranslateToImplementation(d_b, f_v);
    if (XFORM.is_subset(da_fv, f_d) && XFORM.is_subset(db_fv, f_d)){
      result = result :: (m_i, d_j);
    }
  enddo;
  return result;
</xform>

<************************************************************
Helper Functions
*************************************************************>

<***
Input = data_a : a representation of the internal state of the abstraction
Output = position variables of the internal state of the abstraction where position variables are defined as variables not followed by ...
***>
<xform PositionVariablesOfAbstraction pars=(data_a)>
  print("******************************Calling PositionVariables");
  result=NULL;
  foreach n = ID \in data_a do
    result = n :: result;
    <**
    if (!(n : CODE.ZeroOrMoreData)) {
      result = n :: result;
    }
    **>
    <*print("PositionVariblesOfAbstraction's result so far: " result);*>
  enddo;
 return result;
</xform>

<***
Input = vars_i : member variables of C++ class being analyzed
Output = member variables that are pointers
***>
<xform PointerMemberVariablesOfClass pars=(vars_i)>
  print("******************************Calling PointerMemberVariablesOfClass");
  result=NULL;
  foreach decl = CODE.TypeInfo#(t=_,v=_, _) \in vars_i do
    if (t : CODE.PtrType) {
      result = v :: result;
    }
  enddo;
  <*print("PointerMemberVariablesOfClass's result so far: " result);*>
  return result;
</xform>

<*** Input = d_a : an abstraction state that includes list of abstraction variables (e.g., top)
             f_v : mapping of abstraction variables to class variables 
     Output = returns implementation of abstraction state by replacing abstraction var by class variables in the representation of the abstraction state
***>
<xform TranslateToImplementation pars=(d_a, f_v)>
  print("******************************Calling TranslateToImplementation");
  print("d_a in TranslateToImplementation is " d_a);
  print("f_v in TranslateToImplementation is " f_v);
  output = d_a;
  foreach mapping=(v1=_, v2=_) \in f_v do
    output = REPLACE(v1, v2, output);
  enddo;
  print("output in TranslateToImplementation is" output);
  return output;
</xform>

<*** Input = m_a : single abstraction state transition
     Output = d_a : set of abstraction states that can be used as input to state transition m_a 
              d_b : set of abstraction states that can be produced as output by state transition m_a
***>
<xform AbstractionTransition pars=(m_a)>
  print("******************************Calling AbstractionTransition");
  d_a = NULL;
  d_b = NULL;

  <*print("m_a in AbstractionTransition is " m_a);*>

  CODE.AbstractionMethod#(_,body=_) = m_a;

  foreach mspec = CODE.MethodSpec#(r=_,_,o=_,_) \in body do
    d_a = r :: d_a;
    d_b = o :: d_b;
  enddo;

  print("d_a is " d_a);
  print("d_b is " d_b);

  return (d_a, d_b);
</xform>

<xform AdaptApI pars=(a, b)>
  print("******************************Calling AdaptAPI");
</xform>

<*** 
    Input: p_v = position variables of abstraction to be matched against
           p_i = pointer member variables of C++ class to be analyzed
    returns a list of possible implementations of all position variables of abstraction 
***>
<xform PossibleMappings pars=(p_v, p_i)>
  print("******************************Calling PossibleMappings");
  result = NULL;

  foreach pv = ID \in p_v do
    foreach i = ID \in p_i do
      result = (pv, i) :: result;
    enddo;
  enddo;
  
  <*
  foreach pv = ID \in p_v do
    foreach i = CODE.TypeInfo#(t=_,v=_, _) \in p_i do
      result = (pv, v) :: result;
    enddo;
  enddo;
  *>

  return result;
</xform>

<xform SymbolicEvaluation pars=(m_i, f_d)>
  print("******************************Calling SymbolicEvaluation");
  <*DEBUG{m_i};
  DEBUG{f_d};*>
</xform>

<xform CheckEqualityBetweenStates pars=(temp)>
  print("******************************Calling CheckEqualityBetweenStates");
</xform>